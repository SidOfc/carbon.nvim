*carbon.nvim.txt*      The simple directory tree viewer for Neovim written in Lua.
*carbon.txt*

  `Version: 0.8.1`
  `Licence: MIT`
  `Source:  https://github.com/SidOfc/carbon.nvim`
  `Author:  Sidney Liebrand <sidneyliebrand@gmail.com>`

================================================================================
TABLE OF CONTENTS                                     *carbon-contents* *carbon-toc*

  To quickly jump to this table of contents, use |gg| or |go|.
  To navigate to the helptag below the cursor, use CTRL-].

  TABLE OF CONTENTS `.........` |carbon-contents|
  USAGE `.....................` |carbon-usage|
  SETUP `.....................` |carbon-setup|
  COMMANDS `..................` |carbon-commands|
  PLUGS `.....................` |carbon-plugs|
  CARBON `....................` |carbon-carbon|
  UTIL `......................` |carbon-util|
  ENTRY `.....................` |carbon-entry|
  BUFFER `....................` |carbon-buffer|
  WATCHER `...................` |carbon-watcher|
  SETTINGS `..................` |carbon-settings|

================================================================================
USAGE                                                               *carbon-usage*

  Carbon automatically replaces |netrw| and remaps NetRW's |Explore| and
  |Lexplore| commands to Carbon's |Carbon| and |Lcarbon| commands respectively.

  For more specific usage and configuration information, see:

  - |carbon-setup|
  - |carbon-commands|
  - |carbon-autocmds|
  - |carbon-plugs|

================================================================================
SETUP                                                               *carbon-setup*

  The behavior of this plugin can be customized by calling
  `require('carbon').setup` in your |$MYVIMRC| like this:

  init.lua:
  `require('carbon').setup({`
  `  setting = 'value',`
  `})`

  init.vim:
  `lua << EOF`
  `  require('carbon').setup({`
  `    setting = 'value',`
  `  })`
  `EOF`

  If setting options directly is preferred, passing a function is also possible:

  init.lua:
  `require('carbon').setup(function(settings)`
  `  settings.setting = 'value',`
  `end)`

  init.vim:
  `lua << EOF`
  `  require('carbon').setup(function(settings)`
  `    settings.setting = 'value',`
  `  end)`
  `EOF`

  The default settings are documented in |carbon-settings|. Any settings
  supplied to `setup` when called with a table will be deep merged with
  the defaults. When `setup` is called with a function argument, settings
  are directly modified and no merging of any kind will occur.

================================================================================
COMMANDS                                                         *carbon-commands*

  This section documents the behavior as well as the implementation of the
  various |command| commands provided by Carbon.

  `------------------------------------------------------------------------------`
  Carbon                                                                  *Carbon*

  Implementation: `:lua require('carbon').explore()`
  Alias:          Explore unless |carbon-setting-keep-netrw| is enabled.

  Replaces the current buffer with the Carbon buffer.

  `------------------------------------------------------------------------------`
  Lcarbon                                                                *Lcarbon*

  Implementation: `:lua require('carbon').explore_left()`
  Alias:          Lexplore unless |carbon-setting-keep-netrw| is enabled.

  Opens the Carbon buffer in a new vertical split. When Carbon is opened this
  way, pressing the key mapped to |carbon-plug-edit| will open files in a
  split directly to the right.

  `------------------------------------------------------------------------------`
  Fcarbon                                                                *Fcarbon*

  Implementation: `:lua require('carbon').explore_float()`

  Opens the Carbon buffer in a floating window. When Carbon is opened this
  way, Carbon will open files the following way:

  |carbon-plug-edit| will close the floating Carbon window and open the file in
  the current window.

  |carbon-plug-split| will close the floating Carbon window and open the file
  in a split relative to the current window.

  |carbon-plug-vsplit| will close the floating Carbon window and open the file
  in a vertical split relative to the current window.

  See |carbon-setting-float-settings| for more information on how to configure
  the floating window spawned by `:Fcarbon`.

================================================================================
AUTOCMDS                                                         *carbon-autocmds*

  This section documents the default |autocmd| commands that Carbon uses.
  |autocmd| commands are created unconditionally except for
  |carbon-autocmd-dirchanged| which depends on the value of
  |carbon-setting-sync-on-cd|.

  `------------------------------------------------------------------------------`
  BufEnter                                               *carbon-autocmd-bufenter*

  Group:          `Carbon`
  Event:          `BufEnter`
  Pattern:
  Implementation: `lua require('carbon.buffer').process_enter()`

  Local to Carbon buffers.
  Calls |carbon-buffer-process-enter| when entering a Carbon buffer.

  `------------------------------------------------------------------------------`
  BufHidden                                             *carbon-autocmd-bufhidden*

  Group:          `Carbon`
  Event:          `BufHidden`
  Pattern:
  Implementation: `lua require('carbon.buffer').process_hidden()`

  Local to Carbon buffers.
  Calls |carbon-buffer-process-hidden| when the Carbon buffer is hidden.

  `------------------------------------------------------------------------------`
  CursorMovedI                                       *carbon-autocmd-cursormovedi*

  Group:          `Carbon`
  Event:          `CursorMovedI`
  Pattern:
  Implementation: `lua require('carbon.buffer').process_insert_move()`

  Local to Carbon buffers.
  Calls |carbon-buffer-process-insert-move| when moving the cursor in insert mode.
  Used during |carbon-buffer-create| to control the line and minimul column
  offset of the cursor.

  `------------------------------------------------------------------------------`
  DirChanged                                           *carbon-autocmd-dirchanged*

  Group:          `Carbon`
  Event:          `DirChanged`
  Pattern:        `global`
  Implementation: `lua require('carbon').cd()`

  Calls |carbon-buffer-cd| when changing |pwd| using |cd|.

================================================================================
PLUGS                                                               *carbon-plugs*

  This section documents the default |<Plug>| mappings that Carbon provides.
  |<Plug>| mappings are created unconditionally.

  `------------------------------------------------------------------------------`
  <Plug>(carbon-up)                                               *carbon-plug-up*

  Implementation: `:<c-u>lua require('carbon').up()<cr>`
  Mapping:        |carbon-setting-actions-up|

  Sets |carbon-buffer-data-root| to the parent directory of the current
  working directory. Accepts a [count], when given, jumps to [count]nth parent
  directory of the current working directory.

  `------------------------------------------------------------------------------`
  <Plug>(carbon-down)                                           *carbon-plug-down*

  Implementation: `:<c-u>lua require('carbon').down()<cr>`
  Mapping:        |carbon-setting-actions-down|

  Sets |carbon-buffer-data-root| to the directory under the cursor. If the entry
  under the cursor is a file then the parent directory of the file's path will
  be used. Accepts a [count] to allow navigating deeper into compressed paths.
  See |carbon-setting-compress| and |carbon-buffer-down| for more information
  about how compressed paths work and how they are handled.

  `------------------------------------------------------------------------------`
  <Plug>(carbon-reset)                                         *carbon-plug-reset*

  Implementation: `:<c-u>lua require('carbon').reset()<cr>`
  Mapping:        |carbon-setting-actions-reset|

  Sets |carbon-buffer-data-root| to the initial directory that Neovim
  was opened with.

  `------------------------------------------------------------------------------`
  <Plug>(carbon-edit)                                           *carbon-plug-edit*

  Implementation: `:<c-u>lua require('carbon').edit()<cr>`
  Mapping:        |carbon-setting-actions-edit|

  If the entry below the cursor is a directory, expands or collapses the
  directory. Otherwise the file is opened in the current window unless the
  |Lcarbon| or |Fcarbon| command was used.

  `------------------------------------------------------------------------------`
  <Plug>(carbon-split)                                         *carbon-plug-split*

  Implementation: `:<c-u>lua require('carbon').split()<cr>`
  Mapping:        |carbon-setting-actions-split|

  Opens the entry below the cursor in a new |split| if it is a file. If the
  entry is a directory then nothing happens. When Carbon was opened with
  |Fcarbon| this works slightly different. See |Fcarbon| for more information.

  `------------------------------------------------------------------------------`
  <Plug>(carbon-vsplit)                                       *carbon-plug-vsplit*

  Implementation: `:<c-u>lua require('carbon').vsplit()<cr>`
  Mapping:        |carbon-setting-actions-vsplit|

  Opens the entry below the cursor in a new |vsplit| if it is a file. If the
  entry is a directory then nothing happens. When Carbon was opened with
  |Fcarbon| this works slightly different. See |Fcarbon| for more information.

  `------------------------------------------------------------------------------`
  <Plug>(carbon-create)                                       *carbon-plug-create*

  Implementation: `:<c-u>lua require('carbon').create()<cr>`
  Mapping:        |carbon-setting-actions-create|

  Enters a context-aware insert mode in which a file or directory path can be
  typed. When done press <enter> to create the path, any non-existing
  parent directories will be created using |mkdir|. Pressing <enter> without
  typing anything will not create anything. Press <esc> to cancel.

  For more information see |carbon-buffer-create|.

  `------------------------------------------------------------------------------`
  <Plug>(carbon-delete)                                       *carbon-plug-delete*

  Implementation: `:<c-u>lua require('carbon').delete()<cr>`
  Mapping:        |carbon-setting-actions-delete|

  Opens a confirmation popup to confirm whether you want to delete the entry
  under the cursor. Accepts a [count] to allow deleting directories "from left
  to right" when the cursor is on a compressed path
  (more at |carbon-setting-compress|).

  For more information see |carbon-buffer-delete|.

  `------------------------------------------------------------------------------`
  <Plug>(carbon-quit)                                           *carbon-plug-quit*

  Implementation: `:<c-u>lua require('carbon').quit()<cr>`
  Mapping:        |carbon-setting-actions-quit|

  When Carbon is active in the only window and there are multiple buffers
  this mapping will show the |alternate-file|. When Carbon is showing in one of
  several windows, the window will be closed. Finally, if Carbon is the only
  buffer in the only window, nothing happens.

  This mapping will never exit Neovim completely. See |carbon-carbon-quit| for
  more technical details.

================================================================================
CARBON                                                             *carbon-carbon*

  Usage: `require('carbon')`

  This is Carbon's main module. It contains functions which are used for
  setup and initialization and it also defines the core actions which are
  exposed via |<Plug>| mappings

  `------------------------------------------------------------------------------`
  setup                                                      *carbon-carbon-setup*

  Signature: `require('carbon').setup(`{preferences}`)`

  This method updates Carbon's |carbon-settings| with user {preferences}.
  The {preferences} argument can be a table which will be deep-merged with
  |carbon-settings-table| or a callback function which accepts
  |carbon-settings-table| as argument. The callback can modify the settings
  freely. See |carbon-setup| for init.vim / init.lua setup call examples.

  `------------------------------------------------------------------------------`
  initialize                                            *carbon-carbon-initialize*

  Signature: `require('carbon').initialize()`

  Initializes Carbon. This method creates |carbon-commands|, |carbon-plugs|,
  |carbon-autocmds|, and highlights. It hijacks NetRW depending on the value of
  |carbon-setting-keep-netrw| and automatically opens the Carbon buffer if
  Neovim was opened with a directory path depending on |carbon-setting-auto-open|.
  It also attaches a callback to the watcher to enable auto-refreshing the
  buffer when file system events occur.

  This method should be called only once per Neovim instance and must be called
  before any buffer is created otherwise such buffer will not function properly.

  `------------------------------------------------------------------------------`
  edit                                                        *carbon-carbon-edit*

  Signature: `require('carbon').edit()`

  If the entry which the cursor is on is a directory then this method expands
  or collapses it depending on its current state. If it is a file and the
  current buffer was opened using |carbon-carbon-explore-left| then the file will
  be opened in a new split to the right. A split will be created if it does not
  exist. Otherwise if it is a file it will be edited in the current window.

  `------------------------------------------------------------------------------`
  split                                                      *carbon-carbon-split*

  Signature: `require('carbon').split()`

  If the entry which the cursor is on is a directory then this will result in
  a no-op. If it is a file it will be opened in a horizontal split. Respects
  your |splitbelow| preference.

  `------------------------------------------------------------------------------`
  vsplit                                                    *carbon-carbon-vsplit*

  Signature: `require('carbon').vsplit()`

  Like |carbon-carbon-split| but instead of a horizontal split, opens a
  vertical split. Respects your |splitright| preference.

  `------------------------------------------------------------------------------`
  explore                                                  *carbon-carbon-explore*

  Signature: `require('carbon').explore()`

  Show Carbon in the current window. Calls |carbon-buffer-show| internally.
  Used by the |Carbon| command.

  `------------------------------------------------------------------------------`
  explore_left                                        *carbon-carbon-explore-left*

  Signature: `require('carbon').explore_left()`

  Show Carbon in a new vertical split on the left side with a width of
  |carbon-setting-sidebar-width|. Used by the |Lcarbon| command and modifies how
  |carbon-carbon-edit| works for that window.

  `------------------------------------------------------------------------------`
  up                                                            *carbon-carbon-up*

  Signature: `require('carbon').up()`

  Calls |carbon-buffer-up|. When the |buffer-data-root| is updated
  successfully, this method will move the cursor to the top of the buffer and
  rerender.

  `------------------------------------------------------------------------------`
  reset                                                      *carbon-carbon-reset*

  Signature: `require('carbon').reset()`

  Calls |carbon-buffer-reset|. When the |carbon-buffer-data-root| is updated
  successfully, this method will move the cursor to the top of the buffer and
  rerender.

  `------------------------------------------------------------------------------`
  down                                                        *carbon-carbon-down*

  Signature: `require('carbon').down()`

  Calls |carbon-buffer-down|. When the |carbon-buffer-data-root| is updated
  successfully, this method will move the cursor to the top of the buffer and
  rerender.

  `------------------------------------------------------------------------------`
  create                                                    *carbon-carbon-create*

  Signature: `require('carbon').create()`

  Calls |carbon-buffer-create|.

  `------------------------------------------------------------------------------`
  delete                                                    *carbon-carbon-delete*

  Signature: `require('carbon').delete()`

  Calls |carbon-buffer-delete|.

  `------------------------------------------------------------------------------`
  cd                                                            *carbon-carbon-cd*

  Signature: `require('carbon').cd(`[{path}]`)`

  Calls |carbon-buffer-cd| to set |carbon-buffer-data-root| to {path}. If {path}
  is not supplied then |vim.v| variable `vim.v.event.cwd` will be used. When updated
  successfully, this method will move the cursor to the top of the buffer
  and rerender.

  `------------------------------------------------------------------------------`
  quit                                                        *carbon-carbon-quit*

  Signature: `require('carbon').quit()`

  This method calls |nvim_list_wins| to check if there is more than one window, if
  this is the case |nvim_win_close| is called to close the current window.

  When there is only one window this method calls |nvim_list_bufs| to check if
  there is more than one buffer, if this is the case the |alternate-file| is
  shown in the current window if it exists.

  Finally, if the Carbon buffer is the only active buffer in the only active
  window, nothing happens.

================================================================================
UTIL                                                                 *carbon-util*

  Usage: `require('carbon.util')`

  This section describes the internal utilities used by Carbon itself. These
  methods must always be considered unstable and should not be used in code
  external to Carbon.

  `------------------------------------------------------------------------------`
  get_line                                                  *carbon-util-get-line*

  Signature: `require('carbon.util').get_line(`[{lnum}]`)`

  Replacement for |getline|. Returns the content of line {lnum} in the current
  buffer. The cursor line number will be used if {lnum} is not supplied.

  `------------------------------------------------------------------------------`
  cursor                                                      *carbon-util-cursor*

  Signature: `require('carbon.util').cursor(`{row}, {col}`)`

  Wrapper for |nvim_win_set_cursor| which functions more like |cursor| except
  that {col} is zero-based instead of one based.

  `------------------------------------------------------------------------------`
  is_directory                                          *carbon-util-is-directory*

  Signature: `require('carbon.util').is_directory(`{path}`)`

  Uses the `type` attribute returned by `fs_stat` from `vim.loop` to determine
  whether given {path} is a directory. Returns a boolean value or `nil` if the
  call to `fs_stat` failed.

  `------------------------------------------------------------------------------`
  bufwinid                                                  *carbon-util-bufwinid*

  Signature: `require('carbon.util').bufwinid(`{buf}`)`

  Returns the |winid| of buffer {buf}. This method works across all tab pages
  unlike |bufwinid|.

  NOTE: This method will become redundant once implemented in Neovim. See:
  https://github.com/neovim/neovim/issues/18393 for more information.

  `------------------------------------------------------------------------------`
  defer                                                        *carbon-util-defer*

  Signature: `require('carbon.util').defer(`{identifier}, {ms}, {callback}`)`

  Creates a timer for {identifier} which calls {callback} in {ms} milliseconds.
  The {identifier} is a unique string which represents this specific timer.

  See |carbon-util-cancel| to learn more about cancelling deferred callbacks.

  `------------------------------------------------------------------------------`
  cancel                                                      *carbon-util-cancel*

  Signature: `require('carbon.util').cancel(`{identifier}`)`

  Cancels a timer created by |carbon-util-defer|. Results in a no-op if
  {identifier} is not an existing timer.

  `------------------------------------------------------------------------------`
  plug                                                          *carbon-util-plug*

  Signature: `require('carbon.util').plug(`{name}`)`

  Converts {name} to a |<Plug>| map string. For example calling
  `require('carbon.util').plug('up')` will return the string `'<Plug>(carbon-up)'`.

  {name} must be a string.

  `------------------------------------------------------------------------------`
  tbl_find                                                  *carbon-util-tbl-find*

  Signature: `require('carbon.util').tbl_find(`{tbl}, {callback}`)`

  Execute `callback(`{value}, {key}`)` for each value in {tbl} until {callback}
  returns a truthy value. When {callback} returns true, return {value} and
  {key}. When no item is found, return `nil`.

  {tbl} must be a table.
  {callback} must be a function.

  `------------------------------------------------------------------------------`
  tbl_except                                              *carbon-util-tbl-except*

  Signature: `require('carbon.util').tbl_except(`{tbl}, {keys}`)`

  Return a new table with all keys from {tbl} except
  those specified in {keys}.

  {tbl} must be a table.
  {keys} must be a table.

  `------------------------------------------------------------------------------`
  tbl_merge                                                *carbon-util-tbl-merge*

  Signature: `require('carbon.util').tbl_merge(`{...varargs}`)`

  Wraps |vim.tbl_extend|, each {...varargs} argument must be a table. Tables
  are merged using `force` into a new table.

  `------------------------------------------------------------------------------`
  tbl_concat                                              *carbon-util-tbl-concat*

  Signature: `require('carbon.util').tbl_concat(`{...varargs}`)`

  Concatenates all tables.

  String keys will overwrite previously set string keys if they exist.

  Numeric keys are reindexed which means that concatenating tables will change
  the numeric keys of all table values except the first argument.

  For example:

  `util.tbl_concat(`{1, 2, a = 3}, {4, 5, b = 6, a = 7}`)`

  will result in:

  `{1, 2, 4, 5, b = 6, a = 7}`

  `------------------------------------------------------------------------------`
  map                                                            *carbon-util-map*

  Signature: `require('carbon.util').map(`{lhs}, {rhs}[, {options}]`)`

  Wraps |nvim_set_keymap| and |nvim_buf_set_keymap|. Maps {lhs} to {rhs}.
  An optional {options} table can supplied. It accepts the same options
  as |nvim_set_keymap| does and also supports two extra options: `mode` which
  defaults to `'n'` and `buffer` which defaults to `nil`.

  Mappings are |map-silent|, |map-nowait|, and |noremap| by default unless specified
  otherwise in {options}.

  {lhs} must be a string containing the key for this mapping.
  {rhs} must be a vim command string or a lua callback.
  {options} must be a table if supplied.

  When a function is passed to {rhs} `options.callback` will be set to
  {rhs} and {rhs} will be set to an empty string.

  To create a |visual-mode| mapping pass `mode = 'v'`, to create a buffer-local
  mapping pass `buffer = <bufnr>` where `<bufnr>` is a |bufnr()|.

  `------------------------------------------------------------------------------`
  command                                                    *carbon-util-command*

  Signature: `require('carbon.util').command(`{lhs}, {rhs}[, {options}]`)`

  Wraps |nvim_add_user_command|. The only difference between this
  function and |nvim_add_user_command| is that the {options} argument is
  optional, when not passed it will default to an empty table.

  {lhs} must be a string containing the key name for this |user-command|.
  {rhs} must be a vim command string or a lua callback.
  {options} must be a table if supplied.

  `------------------------------------------------------------------------------`
  highlight                                                *carbon-util-highlight*

  Signature: `require('carbon.util').highlight(`{group}, {properties}`)`

  Defines a |highlight| for {group} using provided {properties} and executes that
  command. {group} will be the highlight group name. {properties} is a table
  accepting any properties that can be passed to |highlight|.

  {group} must be a string containing the group name.
  {properties} must be a table.

  `------------------------------------------------------------------------------`
  autocmd                                                    *carbon-util-autocmd*

  Signature: `require('carbon.util').autocmd(`{event}, {cmd_or_cb}[, {opts}]`)`

  Wraps |nvim_create_autocmd|. Sets {opts}`.callback` to {cmd_or_cb} before
  being passed to |nvim_create_autocmd|.

  The {opts}.`group` option will default to `'Carbon'` if not specified.

  Returns the `id` returned by |nvim_create_autocmd|.

  For more information about which autocommands Carbon uses,
  see |carbon-autocmds|.

  `------------------------------------------------------------------------------`
  push_guicursor                                      *carbon-util-push-guicursor*

  Signature: `require('carbon.util').push_guicursor(`{guicursor}`)`

  Stores the previous cursor and changes the cursor to {guicursor}.
  See |guicursor| for more information about the format of {guicursor}.

  To revert the cursor, see |carbon-util-pop-guicursor|

  {guicursor} must be a string.

  `------------------------------------------------------------------------------`
  pop_guicursor                                        *carbon-util-pop-guicursor*

  Signature: `require('carbon.util').pop_guicursor()`

  Revert the last cursor change applied by |carbon-util-push-guicursor|. When
  there are no more changes to revert calling this method results in a no-op.

  `------------------------------------------------------------------------------`
  set_winhl                                                *carbon-util-set-winhl*

  Signature: `require('carbon.util').set_winhl(`{win}, {highlights}`)`

  Overwrite highlights for {win}. The {highlights} table is expected to
  contain "source" group names as keys and "target" group names as values.

  For example:

  `util.set_winhl(`..., {Normal = 'CarbonIndicator', FloatBorder = 'Normal'}`)`

  Will result in the following command being executed:

  `winhl=Normal:CarbonIndicator,FloatBorder:Normal`

  {win} must be a valid |winnr|.
  {highlights} must be a table.

  `------------------------------------------------------------------------------`
  set_buf_autocmds                                  *carbon-util-set-buf-autocmds*

  Signature: `require('carbon.util').set_buf_autocmds(`{buf}, {autocmds}`)`

  Set {autocmds} for {buf}. The {autocmds} table is expected to contain
  {event} keys and their values being a {rhs}.

  Each {event} = {rhs} key-value pair must be valid in |carbon-util-autocmd|.
  The remaining arguments of |carbon-util-autocmd| are automatically set to:

  {buf} must be a valid |bufnr|.
  {autocmds} must be a table.

  `------------------------------------------------------------------------------`
  set_buf_mappings                                  *carbon-util-set-buf-mappings*

  Signature: `require('carbon.util').set_buf_mappings(`{buf}, {mappings}`)`

  Set {mappings} for {buf}. The {mappings} table is expected to be a table
  array of tables where each table has the following layout:

  `{`{lhs}, {rhs}[, {options}]`}`

  The {lhs}, {rhs}, and optional {options} are passed to |carbon-util-map|.

  When {options} is not specified, an empty table is used.
  The `buffer` option in {options} will always be set to {buf} in the call
  to |carbon-util-map|.

  {buf} must be a valid |bufnr|.
  {mappings} must be a table.

  `------------------------------------------------------------------------------`
  create_scratch_buf                              *carbon-util-create-scratch-buf*

  Signature: `require('carbon.util').create_scratch_buf(`[{options}]`)`

  Create a new |unlisted-buffer| which is also a |scratch-buffer|.
  Some buffer options are set by default:

  |bufhidden|  =>  `'wipe'`
  |buftype|    =>  `'nofile'`
  |swapfile|   =>  `false`

  The optional {options} argument is a table which is expected to contain
  buffer "option" names as keys and buffer option values as values.

  Each key-value pair in {options} calls |nvim_buf_set_option| with the
  created buffer's |bufnr| as first argument, the key as second argument, and the
  value as the third argument.

  There are a few special keys which will NOT be passed through to
  |nvim_buf_set_option|. These are:

  - `name`
  - `lines`
  - `mappings`
  - `autocmds`

  When `options.name` is present, the name of the scratch buffer is set to
  the name specified using |nvim_buf_set_name|.

  The `options.lines` setting allows you to specify the initial contents of
  the buffer. The |modified| option will be set to `false` as well.

  When `options.mappings` is specified |carbon-util-set-buf-mappings| is
  called with the created buffer's |bufnr| as first argument and
  `options.mappings` as second argument.

  When `options.autocmds` is specified |carbon-util-set-buf-autocmds| is
  called with the created buffer's |bufnr| as first argument and
  `options.autocmds` as second argument.

  `------------------------------------------------------------------------------`
  confirm                                                    *carbon-util-confirm*

  Signature: `require('carbon.util').confirm(`{options}`)`

  Creates a confirmation popup using |nvim_open_win|. This popup is intended
  to be used to confirm specified actions via provided shortcuts or up/down
  navigation and pressing <enter> to confirm or using <esc> to cancel.

  All default mappings in the popup are unmapped with exception of <k>, <j>,
  <shift-k>, <shift-j>, <up>, <down>, and digits <0> through <9>.

  The {options} argument supports the following keys:

  `{`
  `  row = <number>,`
  `  col = <number>,`
  `  highlight = <string>,`
  `  actions = <table<action>>,`
  `}`

  Property: `row`
  Default:  `vim.fn.line('.')`
  Required: `false`

  The "top" offset in lines at which to anchor the popup.

  Property: `col`
  Default:  `vim.fn.col('.')`
  Required: `false`

  The "left" offset in columns at which to anchor the popup.

  Property: `highlight`
  Default:  `'Normal'`
  Required: `false`

  The highlight group used to highlight |FloatBorder| and |CursorLine|
  in the popup.

  Property: `actions`
  Default:  `nil`
  Required: `true`

  Specify popup actions via a table containing `<action>` entries.
  An `<action>` is a table with the following keys:

  `{`
  `  label = <string>,`
  `  shortcut = <char>,`
  `  callback = <function>,`
  `}`

  Each action specified in `actions` will be shown in the popup. The position of
  each action will be based on its index in the `actions` table. The `label` will be
  the visible text shown in the popup and the `shortcut` key will be shown before
  the `label` between `[` and `]` characters. The `callback` function will be called
  when the action is executed.

  When an `<action>` does not include a `shortcut` it can only be triggered
  using keyboard navigation + <enter>.

  The `label` and `shortcut` properties must be unique within the table of `actions`.

================================================================================
ENTRY                                                               *carbon-entry*

  Usage: `require('carbon.entry')`

  Provides a consistent interface for working with files and directories and
  includes methods for fetching, caching, and sorting entries.
  See |carbon-entry-new| for details on entry objects, a term which will be used
  throughout this documentation to refer to entry instance objects.

  NOTE:
  static methods of this module are called using dot-syntax (`.`) whereas
  instance methods of this module are called using colon-syntax (`:`). This
  difference is visible in the function signature of each method.

  `------------------------------------------------------------------------------`
  new                                                           *carbon-entry-new*

  Signature: `require('carbon.entry').new(`{path}[, {parent}]`)`

  Returns a new entry object for provided absolute {path}. The {path}
  parameter must be a string. {path} may point to files as well as
  directories. When {parent} is supplied, it is set as the entry object's
  `parent` property. {parent} must be another entry object if provided.

  This method will also use |carbon-watcher-register| to register a listener
  for {path}.

  The returned entry object has the following shape:

  `{`
  `  path = '/absolute/path/to/file-or-dir',`
  `  name = 'file-or-dir',`
  `  is_directory = false,`
  `  is_executable = false,`
  `  is_symlink = nil,`
  `}`

  - `path` is the absolute {path}.
  - `name` is the tail of given {path} as returned by |fnamemodify| `:t`.
  - `is_directory` is `true` when |isdirectory| equals `1`.
  - `is_executable` is `true` when |isdirectory| equals `0` and |executable| equals `1`.
  - `is_symlink` is:
    - `2` when {path} does not equal |resolve| of {path} and |getftime| equals `-1`.
    - `1` when {path} does not equal |resolve| of {path} and |getftime| is not `-1`.
    - `nil` otherwise.

  For `is_symlink`, a value of `2` indicates a broken symlink, a value of `1`
  indicates a valid symlink, and `nil` is used when {path} is not a symlink.

  The following methods can be called on entries:

  - |carbon-entry-synchronize|
  - |carbon-entry-children|
  - |carbon-entry-has-children|
  - |carbon-entry-get-children|
  - |carbon-entry-set-children|

  For example: `require('carbon.entry').new('/'):children()` will return a
  table with the direct children of `/` as entry objects.

  This function will fail if {path} is not a path to an existing file or
  directory and passing a {parent} that is not an entry object created via
  `require('carbon.entry').new()` will lead to fatal rendering errors.

  `------------------------------------------------------------------------------`
  find                                                         *carbon-entry-find*

  Signature: `require('carbon.entry').find(`{path}`)`

  Used to find the entry object associated with {path}. The {path} entry must
  already be loaded by Carbon for this to work. That is, it only finds
  children that have already been loaded by Carbon.

  When an entry object's `path` matches {path} it is returned, otherwise the
  return value will be `nil`. This function will not fail if {path}
  is not a string!

  For more information about entry objects, see: |carbon-entry-new|.

  `------------------------------------------------------------------------------`
  clean                                                       *carbon-entry-clean*

  Signature: `require('carbon.entry').clean(`{path}`)`

  Removes all parent and sibling files and directories from the internal
  children cache used by Carbon. Also removes watchers from all removed
  children using |carbon-watcher-release|.

  WARNING:
  It is not recommended to call this method manually because it
  has a high likelyhood of breaking Carbon if not used with caution. It is
  only documented for completeness.

  `------------------------------------------------------------------------------`
  synchronize                                           *carbon-entry-synchronize*

  Signature: `entry:synchronize()`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  When `entry.is_directory` is `false`, nothing happens because Carbon only
  listens to changes to and within directories.

  When `entry.is_directory` is `true` and |isdirectory| of `entry.path` is `1`,
  synchronizes all its children with the current state of the file system
  recursively. Files and folders that were added, removed, renamed, or had
  their permissions changed within `entry.path` will be refreshed.

  When `entry.is_directory` is `true` and |isdirectory| of `entry.path` is `0`
  then |carbon-entry-terminate| is called.

  The method |carbon-watcher-release| will be called with the `path` of each
  entry that will be removed. New entries will automatically call
  |carbon-watcher-register| in |carbon-entry-new|.

  `------------------------------------------------------------------------------`
  terminate                                               *carbon-entry-terminate*

  Signature: `entry:terminate()`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  This method calls |carbon-watcher-release| with `entry.path`, calls
  `entry:terminate` on |carbon-entry-children| if |carbon-entry-has-children|
  is `true`, and if `entry.parent` exists and has children, then entries with
  the same path as `entry.path` are removed.

  The above actions remove an entry from existence within Carbon's state. This
  method only performs in-memory operations on cached children and can be
  safely called on any entry that have since been removed from the file system.

  `------------------------------------------------------------------------------`
  set_open                                                 *carbon-entry-set-open*

  Signature: `entry:set_open(`{value}`)`

  Any truthy value will be treated as if the `entry` is open, any falsy value
  will be treated as if the `entry` is closed.

  `------------------------------------------------------------------------------`
  is_open                                                   *carbon-entry-is-open*

  Signature: `entry:is_open()`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  Returns `true` or `false` depending on the value set by |carbon-entry-set-open|.

  `------------------------------------------------------------------------------`
  set_compressible                                 *carbon-entry-set-compressible*

  Signature: `entry:set_compressible(`{value}`)`

  Any truthy value will be treated as if the `entry` is compressible, any
  falsy value will be treated as if the `entry` is not compressible.

  This method is used by |carbon-buffer-create| to control the rendered
  structure while a new path is being created.

  `------------------------------------------------------------------------------`
  is_compressible                                   *carbon-entry-is-compressible*

  Signature: `entry:is_compressible()`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  Returns `true` by default or otherwise `true` or `false` depending on the value
  set by |carbon-entry-set-compressible|.

  `------------------------------------------------------------------------------`
  children                                                 *carbon-entry-children*

  Signature: `entry:children()`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  When `entry.is_directory` is true, fetches children using
  |carbon-entry-get-children| and caches them. Always returns a table with
  child entry objects or an empty table if it has no children such as regular
  files and empty directories.

  `------------------------------------------------------------------------------`
  has_children                                         *carbon-entry-has-children*

  Signature: `entry:has_children()`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  Returns `true` when children of `entry.path` have already been cached.
  Returns `false` otherwise.

  `------------------------------------------------------------------------------`
  set_children                                         *carbon-entry-set-children*

  Signature: `entry:set_children(`{children}`)`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  Set the cached children of `entry.path` to {children}. The {children} must
  be a table with entry object elements or `nil`.

  When {children} is `nil` the next call to |carbon-entry-children| will
  result in a fresh listing directly from the file system.

  `------------------------------------------------------------------------------`
  get_children                                         *carbon-entry-get-children*

  Signature: `entry:get_children()`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  Returns a table of entry object elements by calling |readdir| on `entry.path`.
  The entry objects will be direct children of `entry.path`. The table will be
  sorted in case-insensitive alphabetical order and all directories will come
  before any files.

  Paths matching any of the patterns defined in |carbon-setting-exclude| will
  be excluded from the returned table.

================================================================================
BUFFER                                                             *carbon-buffer*

  Usage: `require('carbon.buffer')`

  This module is one of Carbon's core modules. It provides methods and
  utilities to show the directory tree, interact with it, and keep it
  synchronized with changes from the file system.

                                                         *carbon-buffer-data-root*

  The following sections may refer to a `data.root` entry object.
  This `data.root` variable is local and private to this module. It is set to
  a |carbon-entry-new| created with the value of |getcwd()| as only argument.

  This variable is the internal representation of the file tree which methods
  such as |carbon-buffer-lines| can use as a data source or methods like
  |carbon-buffer-up|, |carbon-buffer-down|, |carbon-buffer-reset|, or
  |carbon-buffer-cd| can manipulate to enable navigating up from the current
  working directory, down into a child, reset back to the original
  directory Neovim was opened with, or set to an arbitrary path.

  `------------------------------------------------------------------------------`
  set_root                                                *carbon-buffer-set-root*

  Signature: `require('carbon.buffer').set_root(`{new_root}`)`

  The {new_root} argument can be an absolute path to a directory or a
  |carbon-entry-new| entry. When passed as an absolute path it is converted to
  an entry. |carbon-buffer-data-root| is then set to this entry.

  When |carbon-setting-sync-pwd| is enabled Neovim's |pwd| is updated automatically.

  Returns the updated |carbon-buffer-data-root|.

  `------------------------------------------------------------------------------`
  process_event                                      *carbon-buffer-process-event*

  Signature: `require('carbon.buffer').process_event()`

  During |carbon-carbon-initialize| this method is attached using
  |carbon-watcher-on| to process file change events.

  When this method is called, it will start a timer for
  |carbon-setting-sync-delay| milliseconds after which |carbon-buffer-synchronize|
  is called. When called twice within a single |carbon-setting-sync-delay|
  the previous timer will be cancelled and a new one will be started.

  `------------------------------------------------------------------------------`
  process_enter                                      *carbon-buffer-process-enter*

  Signature: `require('carbon.buffer').process_enter()`
  Autocmd:   |carbon-autocmd-bufenter|

  This method sets |fillchars| `eob` to a space to hide the tilde characters after
  the end of the buffer and disables |wrap|.

  `------------------------------------------------------------------------------`
  process_hidden                                    *carbon-buffer-process-hidden*

  Signature: `require('carbon.buffer').process_hidden()`
  Autocmd:   |carbon-autocmd-bufhidden|

  This method restores |fillchars| and |wrap| back to their original values
  before |carbon-buffer-process-enter| was called.

  It also `nils` out both `vim.w.carbon_lexplore_window` and
  `vim.w.carbon_fexplore_window` window-local variables which are used internally
  by |Lcarbon| and |Fcarbon| respectively.

  `------------------------------------------------------------------------------`
  process_insert_move                          *carbon-buffer-process-insert-move*

  Signature: `require('carbon.buffer').process_insert_move()`
  Autocmd:   |carbon-autocmd-cursormovedi|

  This method ensures that the cursor stays within bounds determined by
  |carbon-buffer-create|.

  `------------------------------------------------------------------------------`
  is_loaded                                              *carbon-buffer-is-loaded*

  Signature: `require('carbon.buffer').is_loaded()`

  Returns `true` or `false` depending on whether the current Carbon buffer handle is
  valid and loaded. Uses |nvim_buf_is_loaded| internally.

  `------------------------------------------------------------------------------`
  is_hidden                                              *carbon-buffer-is-hidden*

  Signature: `require('carbon.buffer').is_hidden()`

  Returns `nil` if there is no Carbon buffer handle, `true` if the current buffer
  handle is hidden, and `false` if the current buffer handle is not hidden.
  A buffer is deemed to be hidden when |carbon-util-bufwinid| returns `nil`.

  `------------------------------------------------------------------------------`
  handle                                                    *carbon-buffer-handle*

  Signature: `require('carbon.buffer').handle()`

  Checks the current buffer handle and if valid, returns it. Otherwise creates
  and configures a new buffer, updates the current buffer handle and returns
  the new buffer handle.

  The buffer name will always be `'carbon'` and the following buffer-local
  options are always set:

  |swapfile|    =>  `false`
  |filetype|    =>  `'carbon'`
  |bufhidden|   =>  `'hide'`
  |buftype|     =>  `'nofile'`
  |modifiable|  =>  `false`
  |modified|    =>  `false`

  Finally, if there are actions to map in |carbon-setting-actions| then they
  will be mapped locally to this buffer to a |<Plug>| mapping with the
  same suffix from |carbon-plugs|.

  `------------------------------------------------------------------------------`
  show                                                        *carbon-buffer-show*

  Signature: `require('carbon.buffer').show()`

  Show the Carbon buffer in the current window. Triggers a |carbon-buffer-render|.

  `------------------------------------------------------------------------------`
  render                                                    *carbon-buffer-render*

  Signature: `require('carbon.buffer').render()`

  Renders the Carbon buffer. The contents are determined by calling the
  |carbon-buffer-lines| method with the `data.root` entry object as only
  argument. See |carbon-buffer-data-root| for more information about `data.root`.

  The Carbon buffer is NOT rendered if |carbon-buffer-is-loaded| returns
  `false` or if |carbon-buffer-is-hidden| returns `true`.

  `------------------------------------------------------------------------------`
  cursor                                                    *carbon-buffer-cursor*

  Signature: `require('carbon.buffer').cursor()`

  Returns the result at index `line('.')` from |carbon-buffer-lines| called with
  |carbon-buffer-data-root| as only argument.

  `------------------------------------------------------------------------------`
  lines                                                      *carbon-buffer-lines*

  Signature: `require('carbon.buffer').lines(`{entry}[, {lines}[, {depth}]]`)`

  The {entry} argument must be an entry object as returned by |carbon-entry-new|.
  The {lines} argument is optional. Defaults to an empty table `{}`.
  When {lines} is set to a table, this table will be used instead as accumulator
  for the results. Finally, the optional {depth} argument can be used to specify
  the initial indentation depth. Defaults to `0`.

  Returns a table of "line objects" to render. A "line object" has the
  following data layout:

  `{`
  `  entry = <entry>,`
  `  line = <string>,`
  `  lnum = <number>,`
  `  depth = <number>,`
  `  path = <table<entry>>,`
  `  highlights = <table<table<string, number, number>>>,`
  `}`

  Property: `entry`

  One of the children of {entry}.

  Property: `line`

  This property is set to the text that should be rendered to the buffer.

  Property: `lnum`

  The line number of the entry. Used by |carbon-buffer-create| to determine
  the line number to move to for editing.

  Property: `depth`

  The indent depth of the entry. Used by |carbon-buffer-create| to determine
  the start column to move to for editing.

  Property: `highlights`

  The `highlights` property provides zero or more highlights for the current
  `line`. A highlight in this context is a table with the following structure:

  `{`
  `  <string HighlightGroupName>,`
  `  <number start_column>,`
  `  <number end_column>,`
  `}`

  |carbon-buffer-render| uses |nvim_buf_add_highlight| to set the highlights.
  It is called the following way:

  `vim.api.nvim_buf_add_highlight(`
  `  buffer.handle(),`
  `  data.namespace,`
  `  highlight[1],` => `<string HighlightGroupName>`
  `  lnum - 1,`
  `  highlight[2],` => `<number start_column>`
  `  highlight[3],` => `<number end_column>`
  `)`

  Property: `path`

  When |carbon-setting-compress| is enabled, this table is filled with the
  compressed parent entry objects of `entry`.

  `------------------------------------------------------------------------------`
  synchronize                                          *carbon-buffer-synchronize*

  Signature: `require('carbon.buffer').synchronize()`

  Calls |carbon-entry-synchronize| on |carbon-buffer-data-root| and calls
  |carbon-buffer-render| afterwards.

  `------------------------------------------------------------------------------`
  up                                                            *carbon-buffer-up*

  Signature: `require('carbon.buffer').up(`[{count}]`)`

  Set |carbon-buffer-data-root| to its {count}th parent directory. When {count}
  is not supplied, it will use `vim.v.count1` which defaults to `1` or [count] if
  specified while executing this method in a mapping.

  This method moves the root up one level at a time. It queries the children
  of the parent and replaces the child with the same path as the current
  `data.root` with `data.root`. It also sets `data.root` to an open state so
  when "zooming out" you still see what you had open.

  After doing all this, the `data.root` is finally set to the actual parent.
  This routine then is repeated {count} `- 1` more times.

  When |carbon-setting-sync-pwd| is enabled Neovim's |pwd| is updated automatically.

  Returns `true` if the root is replaced at least once. `nil` otherwise. This
  can happen when you are at your OS root directory and try to go up more.

  `------------------------------------------------------------------------------`
  down                                                        *carbon-buffer-down*

  Signature: `require('carbon.buffer').down(`[{count}]`)`

  Set |carbon-buffer-data-root| to its {count}th child directory below the
  cursor. When {count} is not supplied, it will use `vim.v.count1` which defaults
  to `1` or [count] if specified while executing this method in a mapping.

  Specifying a {count} is only useful when the cursor is on a compressed path.
  The |carbon-setting-compress| section explains how compressed paths work.

  With the cursor on this path `a/b/c/d/e.txt`, calling this method without
  specifying a {count} will move the root to `/a`, you will now see the path
  `b/c/d/e.txt`. If you call the method again, but this time you supply `2` as
  {count} you will navigate "past" `c/` directly into `d/`. You will now only
  see `e.txt`.

  When |carbon-setting-sync-pwd| is enabled Neovim's |pwd| is updated automatically.

  Returns `true` when the root is replaced, `nil` when the `new_root` path is the
  same as the current `data.root` path in which case the root is not replaced.

  `------------------------------------------------------------------------------`
  cd                                                            *carbon-buffer-cd*

  Signature: `require('carbon.buffer').cd(`{path}`)`

  Set |carbon-buffer-data-root| to a |carbon-entry-new| created using {path}.
  This method remembers the state of all child directories when navigating up
  directories. When navigating to a child of the current working directory
  Carbon tries look for any children in its own state to jump to without
  having to perform additional file system reads. In any other case, Carbon
  navigates to the {path} entry object.

  When |carbon-setting-sync-pwd| is enabled Neovim's |pwd| is updated automatically.

  `------------------------------------------------------------------------------`
  reset                                                      *carbon-buffer-reset*

  Signature: `require('carbon.buffer').reset()`

  Set |carbon-buffer-data-root| to the original |pwd| using |carbon-buffer-cd|.
  When |carbon-setting-sync-pwd| is enabled Neovim's |pwd| is updated automatically.

  `------------------------------------------------------------------------------`
  set_lines                                              *carbon-buffer-set-lines*

  Signature: `require('carbon.buffer').set_lines(`{from}, {to}, {strict}, {lines}`)`

  Makes the Carbon buffer |modifiable| and calls |nvim_buf_set_lines| like this:

  `vim.api.nvim_buf_set_lines(`<bufnr>, {from}, {to}, {strict}, {lines}`)`

  After lines have been inserted, Carbon makes the buffer |nomodifiable| and
  sets |modified| to `false`.

  <bufnr> will be set to the current Carbon buffer handle.

  `------------------------------------------------------------------------------`
  add_highlight                                      *carbon-buffer-add-highlight*

  Signature: `require('carbon.buffer').add_highlight(`{hl}, {lnum}, {from}, {to}`)`

  Calls |nvim_buf_add_highlight| like this:

  `vim.api.nvim_buf_add_highlight(`<bufnr>, <ns_id>, {hl}, {lnum}, {from}, {to}`)`

  <bufnr> will be set to the current Carbon buffer handle.
  <ns_id> will be set to the namespace stored internally by Carbon.

  `------------------------------------------------------------------------------`
  clear_namespace                                  *carbon-buffer-clear-namespace*

  Signature: `require('carbon.buffer').clear_namespace(`{from}, {to}`)`

  Calls |nvim_buf_clear_namespace| like this:

  `vim.api.nvim_buf_clear_namespace(`<bufnr>, <ns_id>, {from}, {to}`)`

  <bufnr> will be set to the current Carbon buffer handle.
  <ns_id> will be set to the namespace stored internally by Carbon.

  `------------------------------------------------------------------------------`
  clear_extmarks                                    *carbon-buffer-clear-extmarks*

  Signature: `require('carbon.buffer').clear_extmarks(`{from}, {to}, {opts}`)`

  Wraps |nvim_buf_get_extmarks| and |nvim_buf_del_extmark|. This function
  first calls |nvim_buf_get_extmarks| like this:

  `vim.api.nvim_buf_get_extmarks(`<bufnr>, <ns_id>, {from}, {to}, {opts}`)`

  The resulting list of |extmarks| will all be cleared by calling
  |nvim_buf_del_extmark| like this:

  `vim.api.nvim_buf_del_extmark(`<bufnr>, <ns_id>, <extmark_id>`)`

  <bufnr> will be set to the current Carbon buffer handle.
  <ns_id> will be set to the namespace stored internally by Carbon.

  `------------------------------------------------------------------------------`
  entry_line                                            *carbon-buffer-entry-line*

  Signature: `require('carbon.buffer').entry_line(`{entry}`)`

  Returns line information for given {entry}. The format is the same as a
  single line result from |carbon-buffer-lines|. When {entry} is not visible
  in the buffer this function returns `nil`.

  An entry is visible when it is shown in the buffer. This is also true for
  compressed path entries. While they are not displayed on their "own" line
  they are visible "somewhere" in the buffer.

  In those cases, Carbon returns the line info of the rendered entry which
  will then have {entry} in its `line.path`.

  See |carbon-setting-compress| for more information about compressed paths.

  `------------------------------------------------------------------------------`
  create                                                    *carbon-buffer-create*

  Signature: `require('carbon.buffer').create()`

  When called, puts the Carbon buffer in a context-aware insert mode which
  allows a path to be typed. Pressing <cr> will confirm creation by calling
  |carbon-buffer-create-confirm| and pressing <esc> will cancel creation by
  calling |carbon-buffer-create-cancel|.

  Paths ending in slash (`/`) will create directories, otherwise regular files
  are created.

  The following section will show how this works on regular paths as well as
  compressed paths. It is recommended to familiarize yourself with
  |carbon-setting-compress| before reading on as most of the different
  scenarios involve compressed paths.

  There are a few different cases that can occur. Imagine the following
  directory structure with Neovim opened in a `/home/me/project` directory:

  1 `project/`
  2 `  deeply/nested/file.txt`
  3   `folder/`
  4 `  other/nested/folder/`
  5   `file.txt`

  When called with the cursor on a regular file it will use the parent
  directory of this file as a base for the path to create. If the cursor is
  on line 5, calling this method shows the following:

  1 `project/`
  2 `  deeply/nested/file.txt`
  3   `folder/`
  4 `  other/nested/folder/`
  5   `file.txt`
  6   |

  The parent directory of line 5 is actually `/home/me/project` so you enter
  path creation after all its children in the Carbon buffer (line 6 in this
  contrived case). Typing for example `/new/nested/file.txt` and pressing <cr>
  will create `/home/me/project/new/nested/file.txt`.

  When called with the cursor on a directory, that directory is used as a base
  for the path to create. If the cursor is on line 3, the following will show:

  1 `project/`
  2 `  deeply/nested/file.txt`
  3   `folder/`
  4     |
  5 `  other/nested/folder/`
  6   `file.txt`

  The cursor is placed on line 4 and nested "inside" this folder. Typing
  `/new/nested/file.txt` and pressing <cr> will create
  `/home/me/project/folder/new/nested/file.txt`.

  Finally, when the cursor is on the compressed path on line 2, by default
  the same rules apply as for regular file entries. In this case the base
  will be `/home/me/project/deeply/nested`:

  1 `project/`
  2 `+  deeply/nested/`
  3 `    file.txt`
  4     |
  5   `folder/`
  6 `  other/nested/folder/`
  7   `file.txt`

  Typing `/new/nested/file.txt` and pressing <cr> will create
  `/home/me/project/deeply/nested/new/nested/file.txt`.

  If the cursor was on line 4 instead of line 2, the base path would be
  `/home/me/project/other/nested/folder`:

  1 `project/`
  2 `  deeply/nested/file.txt`
  3   `folder/`
  4 `  other/nested/folder/`
  5     |
  6   `file.txt`

  Typing `/new/nested/file.txt` and pressing <cr> will create
  `/home/me/project/other/nested/folder/new/nested/file.txt`.

  This leaves us with one unresolved scenario, which is how to create files
  or directories at arbitrary parent directories of compressed paths.

  Support for this is implemented via `vim.v.count`. When a count is supplied to
  the mapping executing this function, if this count is greater than `0` then
  Carbon will count directories on compressed paths from left to right, and
  will create a file in the `vim.v.count` nth directory.

  Given the default |carbon-setting-actions-create| mapping of `c`, imagine we
  were on line 2 and pressed `1c`. This would show the following:

  1 `project/`
  2 `  deeply/`
  3 `    nested/file.txt`
  4     |
  3   `folder/`
  4 `  other/nested/folder/`
  5   `file.txt`

  Typing `/new/nested/file.txt` and pressing <cr> will create
  `/home/me/project/deeply/new/nested/file.txt`.

  For compressed paths which end in a directory the same rules apply except
  that by default, the current directory will be used as a base instead of the
  parent directory.

  Finally, when `vim.v.count` does not resolve to a directory, the default
  behavior as if no count was supplied will be executed.

  `------------------------------------------------------------------------------`
  create_confirm                                    *carbon-buffer-create-confirm*

  Signature: `require('carbon.buffer').create_confirm()`

  This method is always mapped to <cr> in |insert-mode|. When <cr> is pressed
  the typed path will be created. Any non-existing parent directories of the
  supplied path will be created as well.

  A path ending in a slash (`/`) will create a directory, otherwise a regular
  file is created.

  Pressing <cr> without typing anything will also not create anything. This is
  effectively the same as pressing <esc> which triggers
  |carbon-buffer-create-cancel|.

  After confirming |carbon-buffer-create-reset| will be called to clean up and
  exit path creation mode.

  WARNING:
  This method is used together with |carbon-buffer-create|. It is not intended
  to be used as a standalone method! It depends on an internal variables
  which are only set when |carbon-buffer-create| is called.

  `------------------------------------------------------------------------------`
  create_cancel                                      *carbon-buffer-create-cancel*

  Signature: `require('carbon.buffer').create_cancel()`

  This method is always mapped to <esc> in |insert-mode|. When <esc> is pressed
  path creation will be cancelled and any typed path will be discarded.

  After confirming |carbon-buffer-create-reset| will be called to clean up and
  exit path creation mode.

  WARNING:
  This method is used together with |carbon-buffer-create|. It is not intended
  to be used as a standalone method! It depends on an internal variables
  which are only set when |carbon-buffer-create| is called.

  `------------------------------------------------------------------------------`
  create_reset                                        *carbon-buffer-create-reset*

  Signature: `require('carbon.buffer').create_reset()`

  Clean up the buffer by removing the temporarily inserted line used for
  typing the path to create, setting both |modifiable| and |modified| to
  `false`, restoring the cursor position, and restoring compressible state.

  After all of the above is executed, all `data.*` variables which were
  created and used in |carbon-buffer-create|, |carbon-buffer-create-confirm|, and
  |carbon-buffer-create-cancel| will be reset to `nil`.

  Finally, |carbon-buffer-render| is called to rerender the buffer.

  WARNING:
  This method is used together with |carbon-buffer-create|. It is not intended
  to be used as a standalone method! It depends on an internal variables
  which are only set when |carbon-buffer-create| is called.

  `------------------------------------------------------------------------------`
  delete                                                    *carbon-buffer-delete*

  Signature: `require('carbon.buffer').delete()`

  Prompts confirmation to delete the current entry under the cursor.
  When the current entry is a regular file or executable the file itself will be
  removed. When it is a directory, the directory and all its contents will be
  removed recursively. Finally, when it is a symlink, just the symlink will be
  removed.

  A [count] can be specified to start deleting from left-to-right. This is
  useful when the cursor is currently positioned on a compressed path.
  It is recommended to familiarize yourself with |carbon-setting-compress| before
  reading on as most of the different scenarios involve compressed paths.

  Imagine the following directory structure with Neovim opened in
  a `/home/me/project` directory:

  1 `project/`
  2 `  deeply/nested/file.txt`
  3   `folder/`
  4 `  other/nested/folder/`
  5   `file.txt`

  If we want to delete the file on line 5 then we can by pressing the mapping
  for |carbon-action-delete|. After doing so the buffer will automatically
  update to reflect the changes:

  1 `project/`
  2 `  deeply/nested/file.txt`
  3   `folder/`
  4 `  other/nested/folder/`

  If we want to delete the `folder/` directory on line 4, we can once again do
  so by pressing the delete mapping. By default, Carbon deletes from right to
  left. The rationale here is based on an assumption that most of the time
  you'll likely find yourself wanting to delete single files so the behaviour
  is streamlined for this use-case.

  Specifying a [count] will reverse the direction so it will delete from left
  to right instead, allowing for deletion of folders at any level of nesting
  in a compressed path. If instead of `folder/` on line 4 we wanted to delete
  `nested` we would prefix the mapping with the number `2` e.g. pressing `2d`
  and confirming deletion on line 4 would result in:

  1 `project/`
  2 `  deeply/nested/file.txt`
  3   `folder/`
  4 `  other/`

  If we wanted to delete the `deeply/` folder on line 2, we would press `1d`
  and confirm deletion, this would leave:

  1 `project/`
  2   `folder/`
  3 `  other/`

  The [count] is clamped. If it exceeds the amount of "components" in the path
  then it will select the last component (the actual entry of that line).

  `------------------------------------------------------------------------------`
  cancel_synchronization                    *carbon-buffer-cancel-synchronization*

  Signature: `require('carbon.buffer').cancel_synchronization()`

  This method cancels the next |carbon-buffer-synchronize| which is planned
  within the next |carbon-setting-sync-delay| time divided by 2.

  File system events are deferred due to the fact that even a single
  change, addition, or deletion of a file or directory will likely lead to
  multiple events firing in quick succession.

  For this reason, buffer synchronization is deferred by
  |carbon-setting-sync-delay| milliseconds. This also means that after an
  event occurs, it will take "some" time before synchronization happens.

  To make sure synchronization skips "work" they themselves are also deferred,
  but by |carbon-setting-sync-delay| time divided by 2 to make sure that
  cancellation happens before the timer runs out. At the same time this also
  removes the need to keep some "skip_next_sync" state which is nice.

================================================================================
WATCHER                                                           *carbon-watcher*

  Usage: `require('carbon.watcher')`

  This module provides a thin wrapper around `vim.loop.new_fs_event`, see
  |watch-file| for more information about `vim.loop.new_fs_event`. Paths can
  be registered using |carbon-watcher-register|, once registered, any change
  to that path will cause an event to be emitted. Registered paths can be
  released using |carbon-watcher-release|. Releasing a path will stop the
  watcher for that path.

  If the path parameter of either of these functions is a directory, then that
  directory and all its children files and directories will be listened to.
  Carbon itself only listens to directories to reduce the amount of file
  watching this plugin does. A single watcher is created for each unique
  directory.

  Finally, |carbon-watcher-on| and |carbon-watcher-off| can be used to
  register callbacks on specific events. The possible events that get
  triggered are:

                                                      *carbon-watcher-event-names*

  - `'change-and-rename'`
  - `'change'`
  - `'rename'`

  `------------------------------------------------------------------------------`
  on                                                           *carbon-watcher-on*

  Signature: `require('carbon.watcher').on(`{event}, {callback}`)`

  The {event} parameter can be given in three different forms:

  When {event} is the string `'*'` then attach {callback} to all events listed
  in |carbon-watcher-event-names|. When {event} is a table of one or more
  |carbon-watcher-event-names| then attach {callback} to each listed event.
  Finally, {event} can be one of |carbon-watcher-event-names|. In this case
  {callback} will be attached only to that event.

                                                      *carbon-watcher-on-callback*

  The {callback} argument must be a function. It receives four arguments and
  can be used like this:

  `function my_callback(`{event}, {dirpath}, {filename}, {error}`)`
  `  print(vim.inspect(`{event}, {dirpath}, {filename}, {error}`))`
  `end`

  `require('carbon.watcher').on('*', my_callback)`

  The {event} argument will be one of |carbon-watcher-event-names|, {dirpath}
  will be the absolute path of the parent directory of the affected path,
  {filename} will be the file name of the affected path and finally, {error}
  will be the value as given by |vim.schedule_wrap()| which the watcher module
  uses internally.

  Another important detail is the fact that we did not pass a closure to `on`
  but we passed a function reference. This is important because the reference
  to the function must be reused in `off` to unbind that specific handler. To
  unbind the above handler, we need to run:

  `require('carbon.watcher').off('*', my_callback)`

  At this point it becomes very clear why passing a closure will not work.
  This design should feel similar to the `window.addEventListener` API
  (https://developer.mozilla.org/docs/Web/API/EventTarget/addEventListener).

  `------------------------------------------------------------------------------`
  off                                                         *carbon-watcher-off*

  Signature: `require('carbon.watcher').off(`{event}, {callback}`)`

  This method accepts the same exact arguments as |carbon-watcher-on| but
  instead of registering {callback} for {event}, it removes {callback}
  from all {event}. See |carbon-watcher-on-callback| for an example using `off`.

  `------------------------------------------------------------------------------`
  emit                                                       *carbon-watcher-emit*

  Signature: `require('carbon.watcher').emit(`{event}[, {...varargs}]`)`

  Emits {event} with {event} as first argument and remaining {...varargs}
  as varargs arguments to registered callbacks. The {event} can only be one of
  |carbon-watcher-event-names|, unlike |carbon-watcher-on| or |carbon-watcher-off|
  which support some shortcuts.

  `------------------------------------------------------------------------------`
  clear                                                     *carbon-watcher-clear*

  Signature: `require('carbon.watcher').clear()`

  This method calls |carbon-watcher-release| on all paths registered using
  |carbon-watcher-register|. This unregisters all the paths but leaves the
  callbacks intact.

  `------------------------------------------------------------------------------`
  release                                                 *carbon-watcher-release*

  Signature: `require('carbon.watcher').release(`{path}`)`

  Unregister a {path} registered by |carbon-watcher-register|. If {path} is not
  registered this will result in a no-op.

  `------------------------------------------------------------------------------`
  register                                               *carbon-watcher-register*

  Signature: `require('carbon.watcher').register(`{path}`)`

  Register an absolute {path}. Once registered, any changes made to this path
  will emit events based on events received from Neovim's lua libuv api
  |vim.loop|.

================================================================================
SETTINGS                                                         *carbon-settings*

  Usage: `require('carbon.settings')`

  Stores all the settings Carbon needs to function properly, it does not expose
  any methods of its own. See below for a table with references to helptags:

                                                           *carbon-settings-table*

  `{`
    `sync_pwd      = `|carbon-setting-sync-pwd|`,`
  `  compress      = `|carbon-setting-compress|`,`
  `  auto_open     = `|carbon-setting-auto-open|`,`
  `  keep_netrw    = `|carbon-setting-keep-netrw|`,`
  `  sync_on_cd    = `|carbon-setting-sync-on-cd|`,`
  `  sync_delay    = `|carbon-setting-sync-delay|`,`
  `  sidebar_width = `|carbon-setting-sidebar-width|`,`
  `  exclude       = `|carbon-setting-exclude|`,`

  `  indicators = {`
  `    expand   = `|carbon-setting-indicators-expand|`,`
  `    collapse = `|carbon-setting-indicators-collapse|`,`
  `  },`

  `  actions = {`
  `    up     = `|carbon-setting-actions-up|`,`
  `    down   = `|carbon-setting-actions-down|`,`
  `    edit   = `|carbon-setting-actions-edit|`,`
  `    reset  = `|carbon-setting-actions-reset|`,`
  `    split  = `|carbon-setting-actions-split|`,`
  `    vsplit = `|carbon-setting-actions-vsplit|`,`
  `    quit   = `|carbon-setting-actions-quit|`,`
  `    create = `|carbon-setting-actions-create|`,`
  `    delete = `|carbon-setting-actions-delete|`,`
  `  },`

  `  highlights = {`
  `    CarbonDir           = `|carbon-setting-highlights-CarbonDir|`,`
  `    CarbonFile          = `|carbon-setting-highlights-CarbonFile|`,`
  `    CarbonExe           = `|carbon-setting-highlights-CarbonExe|`,`
  `    CarbonSymlink       = `|carbon-setting-highlights-CarbonSymlink|`,`
  `    CarbonBrokenSymlink = `|carbon-setting-highlights-CarbonBrokenSymlink|`,`
  `    CarbonIndicator     = `|carbon-setting-highlights-CarbonIndicator|`,`
  `    CarbonDanger        = `|carbon-setting-highlights-CarbonDanger|`,`
  `  },`
  `}`

  Each specific setting is detailed in this module's documentation.

  `------------------------------------------------------------------------------`
  sync_pwd                                               *carbon-setting-sync-pwd*

  Default: `false`

  When enabled, Carbon updates Vim's |pwd| to match the new root path whenever
  the buffer root changes.

  `------------------------------------------------------------------------------`
  compress                                               *carbon-setting-compress*

  Default: `true`

  When enabled, allows Carbon to compress deeply nested children as long as
  they only contain a single child and |carbon-entry-is-compressible| is `true`.
  For example, take the following structure:

  `pwd`
  `|-- a/`
  `|-- |-- b/`
  `|-- |-- |-- c/`
  `|-- |-- |-- |-- d.txt`
  `|-- t/`
  `|-- |-- u/`
  `|-- |-- |-- v.txt`
  `|-- |-- |-- w.txt`
  `|-- |-- x/`
  `|-- |-- |-- y/`
  `|-- |-- |-- |-- z.txt`

  We see here that `a/` contains a single child `b/` which contains a
  single child `c/` which contains a single child `d.txt`. We can also see
  that `t/` contains two children, `u/` which contains `v.txt` and `w.txt`, and `x/`
  which contains a single child `y` which contains a single child `z.txt`. When
  compression is enabled, Carbon shows the above structure like this:

  `pwd/`
  `  a/b/c/d.txt`
  `+ v/`

  Because `a/`, `b/`, `c/`, and `d.txt` are all only children of their parent,
  this path can be compressed to the point where we can directly see `d.txt`
  even though it is nested quite deep in the directory tree. For the other
  directory `t/` however, no compression can take place at the top level
  because `t/` itself contains two children. If we open `t/` however, you will
  see the following:

  `pwd/`
  `  a/b/c/d.txt`
  `- t/`
  `  + u/`
  `    x/y/z.txt`

  We see here that `u/` is not expanded because it contains two children,
  `v.txt` and `w.txt` whereas `x/`, `y/`, and `z.txt` are all only children of
  their parent which means those can be compressed.

  `------------------------------------------------------------------------------`
  auto_open                                             *carbon-setting-auto-open*

  Default: `true`

  When enabled and Neovim is opened with a directory path argument, Carbon's
  buffer will open immediately.

  `------------------------------------------------------------------------------`
  keep_netrw                                           *carbon-setting-keep-netrw*

  Default: `false`

  When `true` NetRW will not be harmed by Carbon. This also means that
  `Explore` and `Lexplore` are no longer aliased to `Carbon` and `Lcarbon` anymore.

  This does not prevent Carbon from showing on vim startup instead of NetRW.
  To control this behavior, see |carbon-setting-auto-open|.

  `------------------------------------------------------------------------------`
  sync_on_cd                                           *carbon-setting-sync-on-cd*

  Default: `not vim.opt.autochdir:get()`

  Disabled by default when |autochdir| is set to `1`, enabled by default when
  |autochdir| set to `0`. When enabled, Carbon listens for `:cd` commands.
  Once a `:cd` command is executed Carbon will automatically update
  |carbon-buffer-data-root| to that path.

  `------------------------------------------------------------------------------`
  sync_delay                                           *carbon-setting-sync-delay*

  Default: `30`

  The amount of milliseconds to wait before updating and rerendering the
  buffer. Carbon debounces file system events by default to reduce the amount
  of updating and rerendering.

  `------------------------------------------------------------------------------`
  sidebar_width                                     *carbon-setting-sidebar-width*

  Default: `30`

  The width in columns of the sidebar window opened by |Lcarbon|.

  `------------------------------------------------------------------------------`
  exclude                                                 *carbon-setting-exclude*

  Default:
    `{`
    `  '~$',`
    `  '#$',`
    `  '%.git$',`
    `  '%.bak$',`
    `  '%.rbc$',`
    `  '%.class$',`
    `  '%.sw[a-p]$',`
    `  '%.py[cod]$',`
    `  '%.Trashes$',`
    `  '%.DS_Store$',`
    `  'Thumbs%.db$',`
    `  '__pycache__',`
    `  'node_modules',`
    `}`

  Paths matching any lua pattern are filtered removed. For more information
  about these patterns, see: https://www.lua.org/pil/20.2.html.
  This setting may be set to `nil` to show everything.

  `------------------------------------------------------------------------------`
  indicators                                           *carbon-setting-indicators*

  Default:
    `{`
    `  expand = '+',`                             *carbon-setting-indicators-expand*
    `  collapse = '-',`                         *carbon-setting-indicators-collapse*
    `}`

  Controls the expand and collapse indicators shown before a directory. Using
  more than one character is allowed. This setting may be set to `nil` to
  disable indicators. Individual indicators can also be disabled by setting
  them to `nil`.

  `------------------------------------------------------------------------------`
  float_settings                                   *carbon-setting-float-settings*

  Default:
    `function()`
      `local columns = vim.opt.columns:get()`
      `local rows = vim.opt.lines:get()`
      `local width = math.min(50, columns * 0.8)`
      `local height = math.min(20, rows * 0.8)`

      `return {`
        `relative = 'editor',`
        `style = 'minimal',`
        `border = 'single',`
        `width = width,`
        `height = height,`
        `col = math.floor(columns / 2 - width / 2),`
        `row = math.floor(rows / 2 - height / 2 - 2),`
      `}`
    `end`

  This setting controls the window settings used in floating windows spawned
  via |Fcarbon|. When set to a table, this table will be passed to
  |nvim_open_window| directly.

  When set to a function, the function will be executed and its return value
  must be a table which will then be passed to |nvim_open_window|. The function
  form allows you to specify the size based on the current dimensions of the
  editor which is not possible when passing a table directly!

  The default function will create a horizontally and vertically centered
  popup with a maximum width of 80% up to 50 columns and maximum height of 80%
  up to 20 lines. All dimensions and offsets will be based on the current
  dimensions of the editor when this function is called.

  `------------------------------------------------------------------------------`
  actions                                                 *carbon-setting-actions*

  Default:
    `{`
    `  up = '[',`                                        *carbon-setting-actions-up*
    `  down = ']',`                                    *carbon-setting-actions-down*
    `  edit = '<cr>',`                                 *carbon-setting-actions-edit*
    `  reset = '.',`                                  *carbon-setting-actions-reset*
    `  split = '<c-x>',`                              *carbon-setting-actions-split*
    `  vsplit = '<c-v>',`                            *carbon-setting-actions-vsplit*
    `  create = 'c',`                                *carbon-setting-actions-create*
    `  delete = 'd',`                                *carbon-setting-actions-delete*
    `  quit = { 'q' '<esc>' },`                        *carbon-setting-actions-quit*
    `}`

  Default mappings for |carbon-plugs|. Setting this to `nil` will prevent
  Carbon from creating any mapping. Setting one of its properties to `nil`
  will disable the mapping for that specific property.

  More than one key may be mapped to an action by supplying a table of keys.
  For example mapping |carbon-setting-actions-reset| to `,` in addition to `.`
  looks like the following:

  `reset = { '.', ',' },`

  Each property maps to a |<Plug>| mapping defined in |carbon-plugs|:

  `up`      =>  |carbon-plug-up|
  `down`    =>  |carbon-plug-down|
  `edit`    =>  |carbon-plug-edit|
  `reset`   =>  |carbon-plug-reset|
  `split`   =>  |carbon-plug-split|
  `vsplit`  =>  |carbon-plug-vsplit|
  `create`  =>  |carbon-plug-create|
  `delete`  =>  |carbon-plug-delete|
  `quit`    =>  |carbon-plug-quit|

  `------------------------------------------------------------------------------`
  highlights                                           *carbon-setting-highlights*

  Default:
    `{`
    `  CarbonDir = {`                          *carbon-setting-highlights-CarbonDir*
    `    ctermfg = 'DarkBlue',`
    `    guifg = '#00aaff',`
    `    cterm = 'bold',`
    `    gui = 'bold',`
    `  },`
    `  CarbonFile = {`                        *carbon-setting-highlights-CarbonFile*
    `    ctermfg = 'LightGray',`
    `    guifg = '#f8f8f8',`
    `    cterm = 'bold',`
    `    gui = 'bold',`
    `  },`
    `  CarbonExe = {`                          *carbon-setting-highlights-CarbonExe*
    `    ctermfg = 'Green',`
    `    guifg = '#22cc22',`
    `    cterm = 'bold',`
    `    gui = 'bold',`
    `  },`
    `  CarbonSymlink = {`                  *carbon-setting-highlights-CarbonSymlink*
    `    ctermfg = 'Magenta',`
    `    guifg = '#d77ee0',`
    `    cterm = 'bold',`
    `    gui = 'bold',`
    `  },`
    `  CarbonBrokenSymlink = {`      *carbon-setting-highlights-CarbonBrokenSymlink*
    `    ctermfg = 'Brown',`
    `    guifg = '#ea871e',`
    `    cterm = 'bold',`
    `    gui = 'bold',`
    `  },`
    `  CarbonIndicator = {`              *carbon-setting-highlights-CarbonIndicator*
    `    ctermfg = 'DarkGray',`
    `    guifg = 'Gray',`
    `    cterm = 'bold',`
    `    gui = 'bold',`
    `  },`
    `  CarbonDanger = {`                    *carbon-setting-highlights-CarbonDanger*
    `    ctermfg = 'Red',`
    `    guifg = '#ff3333',`
    `    cterm = 'bold',`
    `    gui = 'bold',`
    `  },`
    `}`

  The full highlighting configuration used by Carbon. Each key of this table
  will become a highlight group. The table of properties attached to each key will
  determine how the final generated highlight group will look. Any valid
  property of |highlight| commands is also valid in this table.

  The `highlights` setting may be set to `nil` to prevent any highlight groups
  from being generated.

vim:ft=help
