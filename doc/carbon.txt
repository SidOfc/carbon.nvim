*carbon.nvim.txt*      The simple directory tree viewer for Neovim written in Lua.
*carbon.txt*

  `Version: 0.15.0`
  `Licence: MIT`
  `Source:  https://github.com/SidOfc/carbon.nvim`
  `Author:  Sidney Liebrand <sidneyliebrand@gmail.com>`

================================================================================
TABLE OF CONTENTS                                     *carbon-contents* *carbon-toc*

  To quickly jump to this table of contents, use |gg| or |go|.
  To navigate to the helptag below the cursor, use CTRL-].

  TABLE OF CONTENTS `....` |carbon-contents|
  `--------------------------------------`
  USAGE `................` |carbon-usage|
  SETUP `................` |carbon-setup|

  UTIL `.................` |carbon-util|
  ENTRY `................` |carbon-entry|
  PLUGS `................` |carbon-plugs|
  BUFFER `...............` |carbon-buffer|
  CARBON `...............` |carbon-carbon|
  WATCHER `..............` |carbon-watcher|
  COMMANDS `.............` |carbon-commands|
  SETTINGS `.............` |carbon-settings|
  CONSTANTS `............` |carbon-constants|

================================================================================
USAGE                                                               *carbon-usage*

  Carbon automatically replaces |netrw| and remaps NetRW's |Explore| and |Lexplore|
  commands to Carbon's |carbon-command-Carbon| and |carbon-command-Lcarbon| commands
  respectively. For more specific usage and configuration information, see:

  - |carbon-setup|
  - |carbon-commands|
  - |carbon-autocmds|
  - |carbon-plugs|

================================================================================
SETUP                                                               *carbon-setup*

  The behavior of this plugin can be customized by calling
  `require('carbon').setup` in your |$MYVIMRC| like this:

  init.lua: >
  require('carbon').setup({
    setting = 'value',
  })
<
  init.vim: >
  lua << EOF
    require('carbon').setup({
      setting = 'value',
    })
  EOF
<
  If setting options directly is preferred, passing a function is also possible:

  init.lua: >
  require('carbon').setup(function(settings)
    settings.setting = 'value',
  end)
<
  init.vim: >
  lua << EOF
    require('carbon').setup(function(settings)
      settings.setting = 'value',
    end)
  EOF
<
  The default settings are documented in |carbon-settings|. Any settings
  supplied to `setup` when called with a table will be deep merged with
  the defaults. When `setup` is called with a function argument, settings
  are directly modified and no merging of any kind will occur.

================================================================================
CONSTANTS                                                       *carbon-constants*

  Usage: `require('carbon.constants')`

  Exposes a table containing all the constants which Carbon uses.

  `------------------------------------------------------------------------------`
  hl                                                         *carbon-constants-hl*

  Usage: `require('carbon.constants').hl`
  Value: `carbon`

  Used for all default highlighting.

  `------------------------------------------------------------------------------`
  hl_tmp                                                 *carbon-constants-hl-tmp*

  Usage: `require('carbon.constants').hl_tmp`
  Value: `carbon:tmp`

  Used for temporary highlighting. Used only by |carbon-buffer-focus-flash|
  at the moment.

  `------------------------------------------------------------------------------`
  augroup                                                *carbon-constants-augroup*

  Usage: `require('carbon.constants').augroup`
  Value  `carbon:tmp`

  Used for temporary highlighting. Used only by |carbon-buffer-focus-flash|
  at the moment.

================================================================================
COMMANDS                                                         *carbon-commands*

  This section documents the behavior as well as the implementation of the
  various |command| commands provided by Carbon.

  `------------------------------------------------------------------------------`
  Carbon                                                   *carbon-command-Carbon*

  Implementation: `require('carbon').explore()`
  Alias:          `Explore` unless |carbon-setting-keep-netrw| is enabled.

  Replaces the current buffer with the Carbon buffer.
  When called with a <bang> (`Carbon!`) or |carbon-setting-always-reveal| enabled,
  the tree will expand to show the current buffer path and
  |carbon-buffer-flash-bang| it if possible. This also works for its alias.

  `------------------------------------------------------------------------------`
  Lcarbon                                                 *carbon-command-Lcarbon*

  Implementation: `require('carbon').explore_left()`
  Alias:          `Lexplore` unless |carbon-setting-keep-netrw| is enabled.

  Opens the Carbon buffer in a new vertical split. When Carbon is opened this
  way, pressing the key mapped to |carbon-plug-edit| will open files in a
  split directly to the right.

  Subsequent calls will reuse a window previously opened via `Lcarbon` if this
  window still exists and valid.

  When called with a <bang> (`Carbon!`) or |carbon-setting-always-reveal| enabled,
  the tree will expand to show the current buffer path and
  |carbon-buffer-flash-bang| it if possible. This also works for its alias.

  `------------------------------------------------------------------------------`
  Fcarbon                                                 *carbon-command-Fcarbon*

  Implementation: `require('carbon').explore_float()`

  Opens the Carbon buffer in a floating window. When Carbon is opened this
  way, Carbon will open files the following way:

  |carbon-plug-edit| will close the floating Carbon window and open the file in
  the current window.

  |carbon-plug-split| will close the floating Carbon window and open the file
  in a split relative to the current window.

  |carbon-plug-vsplit| will close the floating Carbon window and open the file
  in a vertical split relative to the current window.


  When called with a <bang> (`Carbon!`) or |carbon-setting-always-reveal| enabled,
  the tree will expand to show the current buffer path and
  |carbon-buffer-flash-bang| it if possible.

  See |carbon-setting-float-settings| for more information on how to configure
  the floating window spawned by `:Fcarbon`.

================================================================================
AUTOCMDS                                                         *carbon-autocmds*

  This section documents the default |autocmd| commands that Carbon uses.

  `------------------------------------------------------------------------------`
  BufEnter                                               *carbon-autocmd-bufenter*

  Group:          |carbon-constants-augroup|
  Event:          `BufEnter`
  Pattern:
  Implementation: `require('carbon.buffer').process_enter()`

  Local to Carbon buffers.
  Calls |carbon-buffer-process-enter| when entering a Carbon buffer.

  `------------------------------------------------------------------------------`
  BufHidden                                             *carbon-autocmd-bufhidden*

  Group:          |carbon-constants-augroup|
  Event:          `BufHidden`
  Pattern:
  Implementation: `require('carbon.buffer').process_hidden()`

  Local to Carbon buffers.
  Calls |carbon-buffer-process-hidden| when the Carbon buffer is hidden.

  `------------------------------------------------------------------------------`
  CursorMovedI                                       *carbon-autocmd-cursormovedi*

  Group:          |carbon-constants-augroup|
  Event:          `CursorMovedI`
  Pattern:
  Implementation:

  Local to Carbon buffers. Called when moving the cursor in insert mode.
  Used during |carbon-buffer-create| to control the line and minimul column
  offset of the cursor.

  `------------------------------------------------------------------------------`
  DirChanged                                           *carbon-autocmd-dirchanged*

  Group:          |carbon-constants-augroup|
  Event:          `DirChanged`
  Pattern:        `global`
  Implementation: `require('carbon').cd()`

  Calls |carbon-buffer-cd| when changing |pwd| using |cd|.

================================================================================
PLUGS                                                               *carbon-plugs*

  This section documents the default |<Plug>| mappings that Carbon provides.
  |<Plug>| mappings are created unconditionally.

  `------------------------------------------------------------------------------`
  <Plug>(carbon-up)                                               *carbon-plug-up*

  Implementation: `require('carbon').up()`
  Mapping:        |carbon-setting-actions-up|

  Sets |carbon-buffer-data-root| to the parent directory of the current
  working directory. Accepts a [count], when given, jumps to [count]nth parent
  directory of the current working directory.

  `------------------------------------------------------------------------------`
  <Plug>(carbon-down)                                           *carbon-plug-down*

  Implementation: `require('carbon').down()`
  Mapping:        |carbon-setting-actions-down|

  Sets |carbon-buffer-data-root| to the directory under the cursor. If the entry
  under the cursor is a file then the parent directory of the file's path will
  be used. Accepts a [count] to allow navigating deeper into compressed paths.
  See |carbon-setting-compress| and |carbon-buffer-down| for more information
  about how compressed paths work and how they are handled.

  `------------------------------------------------------------------------------`
  <Plug>(carbon-quit)                                           *carbon-plug-quit*

  Implementation: `require('carbon').quit()`
  Mapping:        |carbon-setting-actions-quit|

  When Carbon is active in the only window and there are multiple buffers
  this mapping will show the |alternate-file|. When Carbon is showing in one of
  several windows, the window will be closed. Finally, if Carbon is the only
  buffer in the only window, nothing happens.

  This mapping will never exit Neovim completely. See |carbon-carbon-quit| for
  more technical details.

  `------------------------------------------------------------------------------`
  <Plug>(carbon-edit)                                           *carbon-plug-edit*

  Implementation: `require('carbon').edit()`
  Mapping:        |carbon-setting-actions-edit|

  If the entry below the cursor is a directory, expands or collapses the
  directory. Otherwise the file is opened in the current window unless the
  |carbon-command-Lcarbon| or |carbon-command-Fcarbon| command was used.

  `------------------------------------------------------------------------------`
  <Plug>(carbon-move)                                           *carbon-plug-move*

  Implementation: `require('carbon').move()`
  Mapping:        |carbon-setting-actions-move|

  Prompts the user to enter a new destination for the entry under the cursor.
  Accepts a [count] to allow left to right selection of the entry to move when
  on a compressed path (|carbon-setting-compress|).

  For more information see |carbon-buffer-move|.

  `------------------------------------------------------------------------------`
  <Plug>(carbon-reset)                                         *carbon-plug-reset*

  Implementation: `require('carbon').reset()`
  Mapping:        |carbon-setting-actions-reset|

  Sets |carbon-buffer-data-root| to the initial directory that Neovim
  was opened with.

  `------------------------------------------------------------------------------`
  <Plug>(carbon-split)                                         *carbon-plug-split*

  Implementation: `require('carbon').split()`
  Mapping:        |carbon-setting-actions-split|

  Opens the entry below the cursor in a new |split| if it is a file. If the
  entry is a directory then nothing happens. When Carbon was opened with
  |carbon-command-Fcarbon| this works slightly different.

  `------------------------------------------------------------------------------`
  <Plug>(carbon-vsplit)                                       *carbon-plug-vsplit*

  Implementation: `require('carbon').vsplit()`
  Mapping:        |carbon-setting-actions-vsplit|

  Opens the entry below the cursor in a new |vsplit| if it is a file. If the
  entry is a directory then nothing happens. When Carbon was opened with
  |carbon-command-Fcarbon| this works slightly different.

  `------------------------------------------------------------------------------`
  <Plug>(carbon-create)                                       *carbon-plug-create*

  Implementation: `require('carbon').create()`
  Mapping:        |carbon-setting-actions-create|

  Enters a context-aware insert mode in which a file or directory path can be
  typed. When done press <enter> to create the path, any non-existing
  parent directories will be created using |mkdir|. Pressing <enter> without
  typing anything will not create anything. Press <esc> to cancel.

  For more information see |carbon-buffer-create|.

  `------------------------------------------------------------------------------`
  <Plug>(carbon-delete)                                       *carbon-plug-delete*

  Implementation: `require('carbon').delete()`
  Mapping:        |carbon-setting-actions-delete|

  Opens a confirmation popup to confirm whether you want to delete the entry
  under the cursor. Accepts a [count] to allow deleting directories "from left
  to right" when the cursor is on a compressed path (|carbon-setting-compress|).

  For more information see |carbon-buffer-delete|.

  `------------------------------------------------------------------------------`
  <Plug>(carbon-close-parent)                           *carbon-plug-close-parent*

  Implementation: `require('carbon').close_parent()`
  Mapping:        |carbon-setting-actions-close-parent|

  Closes the parent directory of the entry the cursor is on. Accepts a [count]
  to allow closing multiple parents at once.

  `------------------------------------------------------------------------------`
  <Plug>(carbon-toggle-recursive)                   *carbon-plug-toggle-recursive*

  Implementation: `require('carbon').toggle_recursive()`
  Mapping:        |carbon-setting-actions-toggle-recursive|

  Recursively opens or closes the entry under the cursor. If the entry is not
  a directory nothing happens.

================================================================================
CARBON                                                             *carbon-carbon*

  Usage: `require('carbon')`

  This is Carbon's main module. It contains functions which are used for
  setup and initialization and it also defines the core actions which are
  exposed via |<Plug>| mappings

  `------------------------------------------------------------------------------`
  setup                                                      *carbon-carbon-setup*

  Signature: `require('carbon').setup(`{preferences}`)`

  This method updates Carbon's |carbon-settings| with user {preferences}.
  The {preferences} argument can be a table which will be deep-merged with
  |carbon-settings-table| or a callback function which accepts
  |carbon-settings-table| as argument. The callback can modify the settings
  freely. See |carbon-setup| for init.vim / init.lua setup call examples.

  `------------------------------------------------------------------------------`
  initialize                                            *carbon-carbon-initialize*

  Signature: `require('carbon').initialize()`

  Initializes Carbon. This method creates |carbon-commands|, |carbon-plugs|,
  |carbon-autocmds|, and highlights. It hijacks NetRW depending on the value of
  |carbon-setting-keep-netrw| and automatically opens the Carbon buffer if
  Neovim was opened with a directory path depending on |carbon-setting-auto-open|.
  It also attaches a callback to the watcher to enable auto-refreshing the
  buffer when file system events occur.

  This method should be called only once per Neovim instance and must be called
  before any buffer is created otherwise such buffer will not function properly.

  `------------------------------------------------------------------------------`
  edit                                                        *carbon-carbon-edit*

  Signature: `require('carbon').edit()`

  If the entry which the cursor is on is a directory then this method expands
  or collapses it depending on its current state. If it is a file and the
  current buffer was opened using |carbon-carbon-explore-left| then the file will
  be opened in a new split to the right. A split will be created if it does not
  exist. Otherwise if it is a file it will be edited in the current window.

  `------------------------------------------------------------------------------`
  split                                                      *carbon-carbon-split*

  Signature: `require('carbon').split()`

  If the entry which the cursor is on is a directory then this will result in
  a no-op. If it is a file it will be opened in a horizontal split. Respects
  your |splitbelow| preference.

  `------------------------------------------------------------------------------`
  vsplit                                                    *carbon-carbon-vsplit*

  Signature: `require('carbon').vsplit()`

  Like |carbon-carbon-split| but instead of a horizontal split, opens a
  vertical split. Respects your |splitright| preference.

  `------------------------------------------------------------------------------`
  explore                                                  *carbon-carbon-explore*

  Signature: `require('carbon').explore(`[{options}]`)`

  Show Carbon in the current window. Calls |carbon-buffer-show| internally.
  Used by the |carbon-command-Carbon| command.

  When {options} is given and `options.bang` is `true` or when
  |carbon-setting-always-reveal| is `true` then this calls
  |carbon-buffer-expand-to-path| to expand the tree to reveal
  the current buffer.

  `------------------------------------------------------------------------------`
  explore_left                                        *carbon-carbon-explore-left*

  Signature: `require('carbon').explore_left(`[{options}]`)`

  Show Carbon in a new vertical split on the left side with a width of
  |carbon-setting-sidebar-width|. Used by the |carbon-command-Lcarbon| command and
  modifies how |carbon-carbon-edit| works for that window.

  When {options} is given and `options.bang` is `true` or when
  |carbon-setting-always-reveal| is `true` then this calls
  |carbon-buffer-expand-to-path| to expand the tree to reveal
  the current buffer.

  Subsequent calls to `:Lcarbon` will attempt to navigate to an existing
  window opened via `:Lcarbon`.

  `------------------------------------------------------------------------------`
  explore_float                                      *carbon-carbon-explore-float*

  Signature: `require('carbon').explore_float(`[{options}]`)`

  Show Carbon in a floating window. Used by the |carbon-command-Fcarbon| command
  and modifies how |carbon-carbon-edit| works for that window.

  When {options} is given and `options.bang` is `true` or when
  |carbon-setting-always-reveal| is `true` then this calls
  |carbon-buffer-expand-to-path| to expand the tree to reveal
  the current buffer.

  `------------------------------------------------------------------------------`
  up                                                            *carbon-carbon-up*

  Signature: `require('carbon').up()`

  Calls |carbon-buffer-up|. When the |buffer-data-root| is updated
  successfully, this method will move the cursor to the top of the buffer and
  rerender.

  `------------------------------------------------------------------------------`
  reset                                                      *carbon-carbon-reset*

  Signature: `require('carbon').reset()`

  Calls |carbon-buffer-reset|. When the |carbon-buffer-data-root| is updated
  successfully, this method will move the cursor to the top of the buffer and
  rerender.

  `------------------------------------------------------------------------------`
  down                                                        *carbon-carbon-down*

  Signature: `require('carbon').down()`

  Calls |carbon-buffer-down|. When the |carbon-buffer-data-root| is updated
  successfully, this method will move the cursor to the top of the buffer and
  rerender.

  `------------------------------------------------------------------------------`
  create                                                    *carbon-carbon-create*

  Signature: `require('carbon').create()`

  Calls |carbon-buffer-create|.

  `------------------------------------------------------------------------------`
  move                                                        *carbon-carbon-move*

  Signature: `require('carbon').move()`

  Calls |carbon-buffer-move|.

  `------------------------------------------------------------------------------`
  delete                                                    *carbon-carbon-delete*

  Signature: `require('carbon').delete()`

  Calls |carbon-buffer-delete|.

  `------------------------------------------------------------------------------`
  cd                                                            *carbon-carbon-cd*

  Signature: `require('carbon').cd(`[{path}]`)`

  Calls |carbon-buffer-cd| to set |carbon-buffer-data-root| to {path}. If {path}
  is not supplied then |vim.v| variable `vim.v.event.cwd` will be used. When updated
  successfully, this method will move the cursor to the top of the buffer
  and rerender.

  `------------------------------------------------------------------------------`
  quit                                                        *carbon-carbon-quit*

  Signature: `require('carbon').quit()`

  This method calls |nvim_list_wins| to check if there is more than one window, if
  this is the case |nvim_win_close| is called to close the current window.

  When there is only one window this method calls |nvim_list_bufs| to check if
  there is more than one buffer, if this is the case the |alternate-file| is
  shown in the current window if it exists.

  Finally, if the Carbon buffer is the only active buffer in the only active
  window, nothing happens.

  `------------------------------------------------------------------------------`
  toggle_recursive                                *carbon-carbon-toggle-recursive*

  Signature: `require('carbon').toggle_recursive()`

  Recursively opens or closes the entry under the cursor. If the entry is not
  a directory nothing happens.

  `------------------------------------------------------------------------------`
  close_parent                                        *carbon-carbon-close-parent*

  Signature: `require('carbon').close_parent()`

  Close the first parent directory under the cursor which can be collapsed. Closes
  `vim.v.count1` amount of collapsible parent directories.

  A parent of any entry is not "collapsible" if it is part of a compressed
  path (|carbon-setting-compress|).
================================================================================
UTIL                                                                 *carbon-util*

  Usage: `require('carbon.util')`

  This section describes the internal utilities used by Carbon itself. These
  methods must always be considered unstable and should not be used in code
  external to Carbon.

  `------------------------------------------------------------------------------`
  is_excluded                                            *carbon-util-is-excluded*

  Signature: `require('carbon.util').is_excluded(`{path}`)`

  Returns `true` if given {path} matches any |carbon-setting-exclude|.
  Will not be called when |carbon-setting-exclude| is set to `nil` or `false`.

  `------------------------------------------------------------------------------`
  cursor                                                      *carbon-util-cursor*

  Signature: `require('carbon.util').cursor(`{row}, {col}`)`

  Wrapper for |nvim_win_set_cursor| which functions more like |cursor| except
  that {col} is zero-based instead of one based.

  `------------------------------------------------------------------------------`
  is_directory                                          *carbon-util-is-directory*

  Signature: `require('carbon.util').is_directory(`{path}`)`

  Uses the `type` attribute returned by `fs_stat` from `vim.loop` to determine
  whether given {path} is a directory. Returns a boolean value or `nil` if the
  call to `fs_stat` failed.

  `------------------------------------------------------------------------------`
  bufwinid                                                  *carbon-util-bufwinid*

  Signature: `require('carbon.util').bufwinid(`{buf}`)`

  Returns the |winid| of buffer {buf}. This method works across all tab pages
  unlike |bufwinid|.

  NOTE: This method will become redundant once implemented in Neovim. See:
  https://github.com/neovim/neovim/issues/18393 for more information.

  `------------------------------------------------------------------------------`
  plug                                                          *carbon-util-plug*

  Signature: `require('carbon.util').plug(`{name}`)`

  Converts {name} to a |<Plug>| map string. For example calling
  `require('carbon.util').plug('up')` will return the string `'<Plug>(carbon-up)'`.

  {name} must be a string.

  `------------------------------------------------------------------------------`
  tbl_find                                                  *carbon-util-tbl-find*

  Signature: `require('carbon.util').tbl_find(`{tbl}, {callback}`)`

  Execute `callback(`{value}, {key}`)` for each value in {tbl} until {callback}
  returns a truthy value. When {callback} returns true, return {value} and
  {key}. When no item is found, return `nil`.

  {tbl} must be a table.
  {callback} must be a function.

  `------------------------------------------------------------------------------`
  tbl_key                                                    *carbon-util-tbl-key*

  Signature: `require('carbon.util').tbl_key(`{tbl}, {item}`)`

  Returns the first key in {tbl} whose value is equal to {item}.
  When multiple keys are bound to the same value any one of those keys can be
  returned at random since Lua's `pairs` does not guarantee any specific ordering
  of keys being looped over.

  Returns `nil` when {item} is not found in {tbl}.

  `------------------------------------------------------------------------------`
  tbl_except                                              *carbon-util-tbl-except*

  Signature: `require('carbon.util').tbl_except(`{tbl}, {keys}`)`

  Return a new table with all keys from {tbl} except
  those specified in {keys}.

  {tbl} must be a table.
  {keys} must be a table.

  `------------------------------------------------------------------------------`
  command                                                    *carbon-util-command*

  Signature: `require('carbon.util').command(`{lhs}, {rhs}[, {options}]`)`

  Wraps |nvim_create_user_command|. The only difference between this
  function and |nvim_create_user_command| is that the {options} argument is
  optional, when not passed it will default to an empty table.

  {lhs} must be a string containing the key name for this |user-command|.
  {rhs} must be a vim command string or a Lua callback.
  {options} must be a table if supplied.

  `------------------------------------------------------------------------------`
  highlight                                                *carbon-util-highlight*

  Signature: `require('carbon.util').highlight(`{group}, {properties}`)`

  Wraps |nvim_set_hl|. The `default` option is set to `true` by default which
  can be overridden by {properties}.

  {group} must be a string containing the group name.
  {properties} must be a table.

  `------------------------------------------------------------------------------`
  autocmd                                                    *carbon-util-autocmd*

  Signature: `require('carbon.util').autocmd(`{event}, {cmd_or_cb}[, {opts}]`)`

  Wraps |nvim_create_autocmd|. Sets {opts}`.callback` to {cmd_or_cb} before
  being passed to |nvim_create_autocmd|.

  The {opts}.`group` option will default to `'Carbon'` if not specified.

  Returns the `id` returned by |nvim_create_autocmd|.

  For more information about which autocommands Carbon uses,
  see |carbon-autocmds|.

  `------------------------------------------------------------------------------`
  clear_autocmd                                        *carbon-util-clear-autocmd*

  Signature: `require('carbon.util').clear_autocmd(`{event}, [, {opts}]`)`

  Wraps |nvim_clear_autocmds|. Sets {opts}`.event` to {event} before being
  passed to |nvim_clear_autocmds|.

  The {opts}.`group` option will default to `'Carbon'` if not specified.

  For more information about which autocommands Carbon uses,
  see |carbon-autocmds|.

  `------------------------------------------------------------------------------`
  set_winhl                                                *carbon-util-set-winhl*

  Signature: `require('carbon.util').set_winhl(`{win}, {highlights}`)`

  Overwrite highlights for {win}. The {highlights} table is expected to
  contain "source" group names as keys and "target" group names as values.

  For example:

  `util.set_winhl(`..., {Normal = 'CarbonIndicator', FloatBorder = 'Normal'}`)`

  Will result in the following command being executed:

  `winhl=Normal:CarbonIndicator,FloatBorder:Normal`

  {win} must be a valid |winnr|.
  {highlights} must be a table.

  `------------------------------------------------------------------------------`
  set_buf_autocmds                                  *carbon-util-set-buf-autocmds*

  Signature: `require('carbon.util').set_buf_autocmds(`{buf}, {autocmds}`)`

  Set {autocmds} for {buf}. The {autocmds} table is expected to contain
  {event} keys and their values being a {rhs}.

  Each {event} = {rhs} key-value pair must be valid in |carbon-util-autocmd|.
  The remaining arguments of |carbon-util-autocmd| are automatically set to:

  {buf} must be a valid |bufnr|.
  {autocmds} must be a table.

  `------------------------------------------------------------------------------`
  set_buf_mappings                                  *carbon-util-set-buf-mappings*

  Signature: `require('carbon.util').set_buf_mappings(`{buf}, {mappings}`)`

  Set {mappings} for {buf}. The {mappings} table is expected to be a table
  of tables where each nested table has the following layout:

  `{`{modes}, {lhs}, {rhs}[, {options}]`}`

  The {modes}, {lhs}, {rhs}, and optional {options} are
  passed to |vim.keymap.set|.

  When {options} is not specified, an empty table is used.
  The `buffer` option in {options} will always be set to {buf} in the call
  to |vim.keymap.set|.

  {buf} must be a valid |bufnr|.
  {mappings} must be a table.

  `------------------------------------------------------------------------------`
  create_scratch_buf                              *carbon-util-create-scratch-buf*

  Signature: `require('carbon.util').create_scratch_buf(`[{options}]`)`

  Create a new |unlisted-buffer| which is also a |scratch-buffer|.
  Some buffer options are set by default:

  |bufhidden|  =>  `'wipe'`
  |buftype|    =>  `'nofile'`
  |swapfile|   =>  `false`

  The optional {options} argument is a table which is expected to contain
  buffer "option" names as keys and buffer option values as values.

  Each key-value pair in {options} calls |nvim_buf_set_option| with the
  created buffer's |bufnr| as first argument, the key as second argument, and the
  value as the third argument.

  There are a few special keys which will NOT be passed through to
  |nvim_buf_set_option|. These are:

  - `name`
  - `lines`
  - `mappings`
  - `autocmds`

  When `options.name` is present, the name of the scratch buffer is set to
  the name specified using |nvim_buf_set_name|.

  The `options.lines` setting allows you to specify the initial contents of
  the buffer. The |modified| option will be set to `false` as well.

  When `options.mappings` is specified |carbon-util-set-buf-mappings| is
  called with the created buffer's |bufnr| as first argument and
  `options.mappings` as second argument.

  When `options.autocmds` is specified |carbon-util-set-buf-autocmds| is
  called with the created buffer's |bufnr| as first argument and
  `options.autocmds` as second argument.

  `------------------------------------------------------------------------------`
  confirm                                                    *carbon-util-confirm*

  Signature: `require('carbon.util').confirm(`{options}`)`

  Creates a confirmation popup using |nvim_open_win|. This popup is intended
  to be used to confirm specified actions via provided shortcuts or up/down
  navigation and pressing <enter> to confirm or using <esc> to cancel.

  All default mappings in the popup are unmapped with exception of <k>, <j>,
  <shift-k>, <shift-j>, <up>, <down>, and digits <0> through <9>.

  The {options} argument supports the following keys:
>
  {
    row = <number>,
    col = <number>,
    highlight = <string>,
    actions = <table<action>>,
  }
<
  Property:    `row`
  Default:     `vim.fn.line('.')`
  Required:    `false`
  Description:
    The "top" offset in lines at which to anchor the popup.

  Property:    `col`
  Default:     `vim.fn.col('.')`
  Required:    `false`
  Description:
    The "left" offset in columns at which to anchor the popup.

  Property:    `highlight`
  Default:     `'Normal'`
  Required:    `false`
  Description:
    The highlight group used to highlight FloatBorder
    (see |nvim_open_win|) and |CursorLine| in the popup.

  Property:    `actions`
  Default:     `nil`
  Required:    `true`
  Description:
    Specify popup actions via a table containing `<action>` entries.
    An `<action>` is a table with the following keys:
>
    {
      label = <string>,
      shortcut = <char>,
      callback = <function>,
    }
<
    Each action specified in `actions` will be shown in the popup. The position
    of each action will be based on its index in the `actions` table. The `label`
    will be the visible text shown in the popup and the `shortcut` key will be
    shown before the `label` between `[` and `]` characters. The `callback` function
    will be called when the action is executed.

    When an `<action>` does not include a `shortcut` it can only be triggered
    using keyboard navigation + <enter>.

    The `label` and `shortcut` properties must be unique within
    the table of `actions`.

================================================================================
ENTRY                                                               *carbon-entry*

  Usage: `require('carbon.entry')`

  Provides a consistent interface for working with files and directories and
  includes methods for fetching, caching, and sorting entries.
  See |carbon-entry-new| for details on entry objects, a term which will be used
  throughout this documentation to refer to entry instance objects.

  NOTE:
  static methods of this module are called using dot-syntax (`.`) whereas
  instance methods of this module are called using colon-syntax (`:`). This
  difference is visible in the function signature of each method.

  `------------------------------------------------------------------------------`
  new                                                           *carbon-entry-new*

  Signature: `require('carbon.entry').new(`{path}[, {parent}]`)`

  Returns a new entry object for provided absolute {path}. The {path}
  parameter must be a string. {path} may point to files as well as
  directories. When {parent} is supplied, it is set as the entry object's
  `parent` property. {parent} must be another entry object if provided.

  This method will also use |carbon-watcher-register| to register a listener
  for {path}.

  The returned entry object has the following shape:
>
  {
    path = '/absolute/path/to/file-or-dir',
    name = 'file-or-dir',
    is_directory = false,
    is_executable = false,
    is_symlink = nil,
  }
<
  - `path` is the absolute {path}.
  - `name` is the tail of given {path} as returned by |fnamemodify| `:t`.
  - `is_directory` is `true` when |isdirectory| equals `1`.
  - `is_executable` is `true` when |isdirectory| equals `0` and |executable| equals `1`.
  - `is_symlink` is:
    - `2` when {path} does not equal |resolve| of {path} and |getftime| equals `-1`.
    - `1` when {path} does not equal |resolve| of {path} and |getftime| is not `-1`.
    - `nil` otherwise.

  For `is_symlink`, a value of `2` indicates a broken symlink, a value of `1`
  indicates a valid symlink, and `nil` is used when {path} is not a symlink.

  The following methods can be called on entries:

  - |carbon-entry-synchronize|
  - |carbon-entry-children|
  - |carbon-entry-has-children|
  - |carbon-entry-get-children|
  - |carbon-entry-set-children|

  For example: `require('carbon.entry').new('/'):children()` will return a
  table with the direct children of `/` as entry objects.

  This function will fail if {path} is not a path to an existing file or
  directory and passing a {parent} that is not an entry object created via
  `require('carbon.entry').new()` will lead to fatal rendering errors.

  `------------------------------------------------------------------------------`
  find                                                         *carbon-entry-find*

  Signature: `require('carbon.entry').find(`{path}`)`

  Used to find the entry object associated with {path}. The {path} entry must
  already be loaded by Carbon for this to work. That is, it only finds
  children that have already been loaded by Carbon.

  When an entry object's `path` matches {path} it is returned, otherwise the
  return value will be `nil`. This function will not fail if {path}
  is not a string!

  For more information about entry objects, see: |carbon-entry-new|.

  `------------------------------------------------------------------------------`
  synchronize                                           *carbon-entry-synchronize*

  Signature: `entry:synchronize(`{paths}`)`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  Returns `nil` when `entry.is_directory` is `false`.

  When `entry.path` is not an existing key in the {paths} table and
  `entry:has_children()` is true, calls |carbon-entry-synchronize| on each
  child in `entry:children()`.

  When `entry.path` is an existing key in the {paths} table the previous
  children will be compared with the current children.

  This is done by collecting a list of unique paths from both previous and
  current children and then looping over each. Each unique path may have a
  `previous` and a `current` version. The following rules are then applied:

  1. When both `previous` and `current` are available and `current.is_directory`
     is `true` then |carbon-entry-set-open| is called on `current` with the value
     of |carbon-entry-is-open| of `previous` and finally `entry:synchronize(`{paths}`)`
     is called.

  2. When `previous` exists but `current` does not then
     |carbon-entry-terminate| is called on `previous`.

  3. When `current` exists but `previous` does not then nothing happens. The
     `current` entry is already an active child and `previous` has already
     been terminated.

  `------------------------------------------------------------------------------`
  terminate                                               *carbon-entry-terminate*

  Signature: `entry:terminate()`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  This method calls |carbon-watcher-release| with `entry.path`, calls
  `entry:terminate` on |carbon-entry-children| if |carbon-entry-has-children|
  is `true`, and if `entry.parent` exists and has children, then entries with
  the same path as `entry.path` are removed.

  The above actions remove an entry from existence within Carbon's state. This
  method only performs in-memory operations on cached children and can be
  safely called on any entry that have since been removed from the file system.

  `------------------------------------------------------------------------------`
  set_open                                                 *carbon-entry-set-open*

  Signature: `entry:set_open(`{value}[, {recursive}]`)`

  Any truthy {value} will be treated as if the `entry` is open, any falsy {value}
  will be treated as if the `entry` is closed.

  When {recursive} is truthy and `entry:has_children()` is also true, traverse
  child directories and set them to the same {value} recursively.

  `------------------------------------------------------------------------------`
  is_open                                                   *carbon-entry-is-open*

  Signature: `entry:is_open()`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  Returns `true` or `false` depending on the value set by |carbon-entry-set-open|.

  `------------------------------------------------------------------------------`
  set_compressible                                 *carbon-entry-set-compressible*

  Signature: `entry:set_compressible(`{value}`)`

  Any truthy value will be treated as if the `entry` is compressible, any
  falsy value will be treated as if the `entry` is not compressible.

  This method is used by |carbon-buffer-create| to control the rendered
  structure while a new path is being created.

  `------------------------------------------------------------------------------`
  is_compressible                                   *carbon-entry-is-compressible*

  Signature: `entry:is_compressible()`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  Returns `true` by default or otherwise `true` or `false` depending on the value
  set by |carbon-entry-set-compressible|.

  `------------------------------------------------------------------------------`
  children                                                 *carbon-entry-children*

  Signature: `entry:children()`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  When `entry.is_directory` is true, fetches children using
  |carbon-entry-get-children| and caches them. Always returns a table with
  child entry objects or an empty table if it has no children such as regular
  files and empty directories.

  `------------------------------------------------------------------------------`
  has_children                                         *carbon-entry-has-children*

  Signature: `entry:has_children()`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  Returns `true` when children of `entry.path` have already been cached.
  Returns `false` otherwise.

  `------------------------------------------------------------------------------`
  set_children                                         *carbon-entry-set-children*

  Signature: `entry:set_children(`{children}`)`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  Set the cached children of `entry.path` to {children}. The {children} must
  be a table with entry object elements or `nil`.

  When {children} is `nil` the next call to |carbon-entry-children| will
  result in a fresh listing directly from the file system.

  `------------------------------------------------------------------------------`
  get_children                                         *carbon-entry-get-children*

  Signature: `entry:get_children()`

  The variable `entry` in this section refers to an entry object as returned by
  the |carbon-entry-new| method.

  Returns a table of entry object elements by calling |readdir| on `entry.path`.
  The entry objects will be direct children of `entry.path`. The table will be
  sorted in case-insensitive alphabetical order and all directories will come
  before any files.

  Paths matching any of the patterns defined in |carbon-setting-exclude| will
  be excluded from the returned table.

================================================================================
BUFFER                                                             *carbon-buffer*

  Usage: `require('carbon.buffer')`

  This module is one of Carbon's core modules. It provides methods and
  utilities to show the directory tree, interact with it, and keep it
  synchronized with changes from the file system.

                                                         *carbon-buffer-data-root*

  The following sections may refer to a `data.root` entry object.
  This `data.root` variable is local and private to this module. It is set to
  a |carbon-entry-new| created with the value of |getcwd()| as only argument.

  This variable is the internal representation of the file tree which methods
  such as |carbon-buffer-lines| can use as a data source or methods like
  |carbon-buffer-up|, |carbon-buffer-down|, |carbon-buffer-reset|, or
  |carbon-buffer-cd| can manipulate to enable navigating up from the current
  working directory, down into a child, reset back to the original
  directory Neovim was opened with, or set to an arbitrary path.

  `------------------------------------------------------------------------------`
  focus_flash                                          *carbon-buffer-focus-flash*

  Signature: `require('carbon.buffer').focus_flash(`{duration}, {group},
                                                  {start}, {finish}`)`

  Highlights a region from {start} to {finish} with {group} for {duration}
  milliseconds. {start} and {finish} must be values accepted by
  |vim.highlight.range|.

  See |carbon-buffer-flash-bang| for more information about customizing the
  highlighting properties when entries are revealed.

  `------------------------------------------------------------------------------`
  expand_to_path                                    *carbon-buffer-expand-to-path*

  Signature: `require('carbon.buffer').expand_to_path(`{path}`)`

  Expands the Carbon buffer to reveal {path} in the tree. If {path} is not
  present within |carbon-buffer-data-root| this will result in a no-op.

  When successful this sets `data.flash` to the entry identified by {path}.
  This causes the next call to |carbon-buffer-render| to move to and highlight
  the entry |carbon-buffer-flash-bang|.

  Given {path} will be converted to an absolute path automatically by means of
  calling |fnamemodify| with the `:p` flag. You do not need to pass an
  absolute path yourself.

  This method also works when Carbon is not currently visible. It will fail
  only if {path} is not a string.

  The buffer is NOT rerendered automatically, this must be done manually by
  calling |carbon-buffer-render| afterwards.

  `------------------------------------------------------------------------------`
  set_root                                                *carbon-buffer-set-root*

  Signature: `require('carbon.buffer').set_root(`{new_root}`)`

  The {new_root} argument can be an absolute path to a directory or a
  |carbon-entry-new| entry. When passed as an absolute path it is converted to
  an entry. |carbon-buffer-data-root| is then set to this entry.

  When |carbon-setting-sync-pwd| is enabled Neovim's |pwd| is updated automatically.

  Returns the updated |carbon-buffer-data-root|.

  `------------------------------------------------------------------------------`
  launch                                                    *carbon-buffer-launch*

  Signature: `require('carbon.buffer').launch(`{new_root}`)`

  Called during |carbon-carbon-initialize| when |carbon-setting-auto-open| is set
  and Neovim is opened with a directory or no argument. Not called when
  Neovim is opened with a regular file.

  Calls |carbon-buffer-set-root| with {new_root} and then calls |carbon-buffer-show|.
  Also set the reset directory used by |carbon-plug-reset| to navigate back to.

  Returns the updated |carbon-buffer-data-root|.

  `------------------------------------------------------------------------------`
  process_event                                      *carbon-buffer-process-event*

  Signature: `require('carbon.buffer').defer_resync()`

  During |carbon-carbon-initialize| this method is attached using
  |carbon-watcher-on| to process file change events.

  When this method is called, it will start a timer for
  |carbon-setting-sync-delay| milliseconds after which |carbon-buffer-synchronize|
  is called. When called twice within a single |carbon-setting-sync-delay|
  the previous timer will be cancelled and a new one will be started.

  `------------------------------------------------------------------------------`
  process_enter                                      *carbon-buffer-process-enter*

  Signature: `require('carbon.buffer').process_enter()`
  Autocmd:   |carbon-autocmd-bufenter|

  This method sets |fillchars| `eob` to a space to hide the tilde characters after
  the end of the buffer and disables |wrap|.

  `------------------------------------------------------------------------------`
  process_hidden                                    *carbon-buffer-process-hidden*

  Signature: `require('carbon.buffer').process_hidden()`
  Autocmd:   |carbon-autocmd-bufhidden|

  This method restores |fillchars| and |wrap| back to their original values
  before |carbon-buffer-process-enter| was called.

  It also `nils` out both `vim.w.carbon_lexplore_window` and
  `vim.w.carbon_fexplore_window` window-local variables which are used internally
  by |carbon-command-Lcarbon| and |carbon-command-Fcarbon| respectively.

  `------------------------------------------------------------------------------`
  is_loaded                                              *carbon-buffer-is-loaded*

  Signature: `require('carbon.buffer').is_loaded()`

  Returns `true` or `false` depending on whether the current Carbon buffer handle is
  valid and loaded. Uses |nvim_buf_is_loaded| internally.

  `------------------------------------------------------------------------------`
  is_hidden                                              *carbon-buffer-is-hidden*

  Signature: `require('carbon.buffer').is_hidden()`

  Returns `nil` if there is no Carbon buffer handle, `true` if the current buffer
  handle is hidden, and `false` if the current buffer handle is not hidden.
  A buffer is deemed to be hidden when |carbon-util-bufwinid| returns `nil`.

  `------------------------------------------------------------------------------`
  handle                                                    *carbon-buffer-handle*

  Signature: `require('carbon.buffer').handle()`

  Checks the current buffer handle and if valid, returns it. Otherwise creates
  and configures a new buffer, updates the current buffer handle and returns
  the new buffer handle.

  The buffer name will always be `'carbon'` and the following buffer-local
  options are always set:

  |swapfile|    =>  `false`
  |filetype|    =>  `'carbon'`
  |bufhidden|   =>  `'hide'`
  |buftype|     =>  `'nofile'`
  |modifiable|  =>  `false`
  |modified|    =>  `false`

  Finally, if there are actions to map in |carbon-setting-actions| then they
  will be mapped locally to this buffer to a |<Plug>| mapping with the
  same suffix from |carbon-plugs|.

  `------------------------------------------------------------------------------`
  show                                                        *carbon-buffer-show*

  Signature: `require('carbon.buffer').show()`

  Show the Carbon buffer in the current window. Triggers a |carbon-buffer-render|.

  `------------------------------------------------------------------------------`
  render                                                    *carbon-buffer-render*

  Signature: `require('carbon.buffer').render()`

  Renders the Carbon buffer. The contents are determined by calling the
  |carbon-buffer-lines| method with the `data.root` entry object as only
  argument. See |carbon-buffer-data-root| for more information about `data.root`.

  The Carbon buffer is NOT rendered if |carbon-buffer-is-loaded| returns
  `false` or if |carbon-buffer-is-hidden| returns `true`.

                                                        *carbon-buffer-flash-bang*

  After rendering, if `data.flash` is set to an entry which is currently visible,
  (it is set by |carbon-buffer-expand-to-path|) then the cursor will move to
  that entry and reset `data.flash` to `nil`.

  Additionally, when this happens, that entry is also highlighted using
  |carbon-setting-highlights-CarbonFlash|. The delay and duration of the
  highlight are controlled by |carbon-setting-flash|.

  `------------------------------------------------------------------------------`
  cursor                                                    *carbon-buffer-cursor*

  Signature: `require('carbon.buffer').cursor(`[{opts}]`)`

  Returns a table with the following shape:
>
  {
    line = <line>,
    target = <entry>,
    target_line = <line>,
  }
<
  Property: `line`

  An item at index `line('.')` from |carbon-buffer-lines|.

  Property: `target`

  Equal to `line.entry` by default but when called during a mapping, will respect
  |v:count| where possible. This is used for example to start deleting from
  "left to right" on compressed paths by prefixing a mapping with a [count].

  When {opts}`.target_directory_only` is truthy and `target.is_directory` is `false`
  then `target` will be set to `line.path[#line.path] or target.parent` BEFORE
  any [count] logic is applied.

  One way to describe the difference between `line.entry` and `target` is that
  `line.entry` will always point to the last path component entry on the current
  line whereas `target` points to the entry targetted by the user.

  Property: `target_line`

  Like `line` but `target_line` refers to the line which `target` is located on.

  For more information about compressed paths, see: |carbon-setting-compress|.

  `------------------------------------------------------------------------------`
  lines                                                      *carbon-buffer-lines*

  Signature: `require('carbon.buffer').lines(`{entry}[, {lines}[, {depth}]]`)`

  The {entry} argument must be an entry object as returned by |carbon-entry-new|.
  The {lines} argument is optional. Defaults to an empty table `{}`. When {lines}
  is set to a table, this table will be used instead as accumulator value.
  Finally, the optional {depth} argument can be used to specify the initial
  indentation depth. Defaults to `0`.

  Returns a table of "line objects" to render. A "line object" has the
  following data layout:
>
  {
    entry = <entry>,
    line = <string>,
    lnum = <number>,
    depth = <number>,
    path = <table<entry>>,
    highlights = <table<table<string, number, number>>>,
  }
<
  Property: `entry`

  One of the children of {entry}.

  Property: `line`

  This property is set to the text that should be rendered to the buffer.

  Property: `lnum`

  The line number of the entry. Used by |carbon-buffer-create| to determine
  the line number to move to for editing.

  Property: `depth`

  The indent depth of the entry. Used by |carbon-buffer-create| to determine
  the start column to move to for editing.

  Property: `highlights`

  The `highlights` property provides zero or more highlights for the current
  `line`. A highlight in this context is a table with the following structure:
>
  {
    <string HighlightGroupName>,
    <number start_column>,
    <number end_column>,
  }
<
  |carbon-buffer-render| uses |nvim_buf_add_highlight| to set the highlights.
  It is called the following way:
>
  vim.api.nvim_buf_add_highlight(
    buffer.handle(),
    require('util.constants').hl,
    highlight[1],
    lnum - 1,
    highlight[2],
    highlight[3],
  )
<
  Property: `path`

  When |carbon-setting-compress| is enabled, this table is filled with the
  compressed parent entry objects of `entry`.

  `------------------------------------------------------------------------------`
  synchronize                                          *carbon-buffer-synchronize*

  Signature: `require('carbon.buffer').synchronize()`

  Calls |carbon-entry-synchronize| on |carbon-buffer-data-root| and calls
  |carbon-buffer-render| afterwards.

  `------------------------------------------------------------------------------`
  up                                                            *carbon-buffer-up*

  Signature: `require('carbon.buffer').up(`[{count}]`)`

  Set |carbon-buffer-data-root| to its {count}th parent directory. When {count}
  is not supplied, it will use `vim.v.count1` which defaults to `1` or [count] if
  specified while executing this method in a mapping.

  This method moves the root up one level at a time. It queries the children
  of the parent and replaces the child with the same path as the current
  `data.root` with `data.root`. It also sets `data.root` to an open state so
  when "zooming out" you still see what you had open.

  After doing all this, the `data.root` is finally set to the actual parent.
  This routine then is repeated {count} `- 1` more times.

  When |carbon-setting-sync-pwd| is enabled Neovim's |pwd| is updated automatically.

  Returns `true` if the root is replaced at least once. `nil` otherwise. This
  can happen when you are at your OS root directory and try to go up more.

  `------------------------------------------------------------------------------`
  down                                                        *carbon-buffer-down*

  Signature: `require('carbon.buffer').down(`[{count}]`)`

  Set |carbon-buffer-data-root| to its {count}th child directory below the
  cursor. When {count} is not supplied, it will use `vim.v.count1` which defaults
  to `1` or [count] if specified while executing this method in a mapping.

  Specifying a {count} is only useful when the cursor is on a compressed path.
  The |carbon-setting-compress| section explains how compressed paths work.

  With the cursor on this path `a/b/c/d/e.txt`, calling this method without
  specifying a {count} will move the root to `/a`, you will now see the path
  `b/c/d/e.txt`. If you call the method again, but this time you supply `2` as
  {count} you will navigate "past" `c/` directly into `d/`. You will now only
  see `e.txt`.

  When |carbon-setting-sync-pwd| is enabled Neovim's |pwd| is updated automatically.

  Returns `true` when the root is replaced, `nil` when the `new_root` path is the
  same as the current `data.root` path in which case the root is not replaced.

  `------------------------------------------------------------------------------`
  cd                                                            *carbon-buffer-cd*

  Signature: `require('carbon.buffer').cd(`{path}`)`

  Set |carbon-buffer-data-root| to a |carbon-entry-new| created using {path}.
  This method remembers the state of all child directories when navigating up
  directories. When navigating to a child of the current working directory
  Carbon tries look for any children in its own state to jump to without
  having to perform additional file system reads. In any other case, Carbon
  navigates to the {path} entry object.

  When |carbon-setting-sync-pwd| is enabled Neovim's |pwd| is updated automatically.

  `------------------------------------------------------------------------------`
  reset                                                      *carbon-buffer-reset*

  Signature: `require('carbon.buffer').reset()`

  Set |carbon-buffer-data-root| to the original |pwd| using |carbon-buffer-cd|.
  When |carbon-setting-sync-pwd| is enabled Neovim's |pwd| is updated automatically.

  `------------------------------------------------------------------------------`
  set_lines                                              *carbon-buffer-set-lines*

  Signature: `require('carbon.buffer').set_lines(`{from}, {to}, {lines}`)`

  Makes the Carbon buffer |modifiable| and calls |nvim_buf_set_lines| like this:

  `vim.api.nvim_buf_set_lines(`<bufnr>, {from}, {to}, 1, {lines}`)`

  After lines have been inserted Carbon sets |modified| to `false`.
  Will also set |nomodifiable| to `true` except when called in |insert-mode|.

  <bufnr> will be set to the |bufnr| of the Carbon buffer.

  `------------------------------------------------------------------------------`
  add_highlight                                      *carbon-buffer-add-highlight*

  Signature: `require('carbon.buffer').add_highlight(`{hl}, {lnum}, {from}, {to}`)`

  Calls |nvim_buf_add_highlight| like this:

  `vim.api.nvim_buf_add_highlight(`<bufnr>, <ns_id>, {hl}, {lnum}, {from}, {to}`)`

  <bufnr> will be set to the |bufnr| of the Carbon buffer.
  <ns_id> will be set to the namespace stored internally by Carbon.

  `------------------------------------------------------------------------------`
  clear_namespace                                  *carbon-buffer-clear-namespace*

  Signature: `require('carbon.buffer').clear_namespace(`{from}, {to}`)`

  Calls |nvim_buf_clear_namespace| like this:

  `vim.api.nvim_buf_clear_namespace(`<bufnr>, <ns_id>, {from}, {to}`)`

  <bufnr> will be set to the |bufnr| of the Carbon buffer.
  <ns_id> will be set to the namespace stored internally by Carbon.

  `------------------------------------------------------------------------------`
  clear_extmarks                                    *carbon-buffer-clear-extmarks*

  Signature: `require('carbon.buffer').clear_extmarks(`{from}, {to}, {opts}`)`

  Wraps |nvim_buf_get_extmarks| and |nvim_buf_del_extmark|. This function
  first calls |nvim_buf_get_extmarks| like this:

  `vim.api.nvim_buf_get_extmarks(`<bufnr>, <ns_id>, {from}, {to}, {opts}`)`

  The resulting list of |extmarks| will all be cleared by calling
  |nvim_buf_del_extmark| like this:

  `vim.api.nvim_buf_del_extmark(`<bufnr>, <ns_id>, <extmark_id>`)`

  <bufnr> will be set to the |bufnr| of the Carbon buffer.
  <ns_id> will be set to the namespace stored internally by Carbon.

  `------------------------------------------------------------------------------`
  entry_line                                            *carbon-buffer-entry-line*

  Signature: `require('carbon.buffer').entry_line(`{entry}`)`

  Returns line information for given {entry}. The format is the same as a
  single line result from |carbon-buffer-lines|. When {entry} is not visible
  in the buffer this function returns `nil`.

  An entry is visible when it is shown in the buffer. This is also true for
  compressed path entries. While they are not displayed on their "own" line
  they are visible "somewhere" in the buffer.

  In those cases, Carbon returns the line info of the rendered entry which
  will then have {entry} in its `line.path`.

  See |carbon-setting-compress| for more information about compressed paths.

  `------------------------------------------------------------------------------`
  create                                                    *carbon-buffer-create*

  Signature: `require('carbon.buffer').create()`

  When called, puts the Carbon buffer in a context-aware insert mode which
  allows a path to be typed. Pressing <cr> will confirm creation and pressing
  <esc> will cancel creation.

  Paths ending in slash (`/`) will create directories, otherwise regular files
  are created.

  The following section will show how this works on regular paths as well as
  compressed paths. It is recommended to familiarize yourself with
  |carbon-setting-compress| before reading on as most of the different
  scenarios involve compressed paths.

  There are a few different cases that can occur. Imagine the following
  directory structure with Neovim opened in a `/home/me/project` directory:

  1 `project/`
  2 `  deeply/nested/file.txt`
  3   `folder/`
  4 `  other/nested/folder/`
  5   `file.txt`

  When called with the cursor on a regular file it will use the parent
  directory of this file as a base for the path to create. If the cursor is
  on line 5, calling this method shows the following:

  1 `project/`
  2 `  deeply/nested/file.txt`
  3   `folder/`
  4 `  other/nested/folder/`
  5   `file.txt`
  6   |

  The parent directory of line 5 is actually `/home/me/project` so you enter
  path creation after all its children in the Carbon buffer (line 6 in this
  contrived case). Typing for example `/new/nested/file.txt` and pressing <cr>
  will create `/home/me/project/new/nested/file.txt`.

  When called with the cursor on a directory, that directory is used as a base
  for the path to create. If the cursor is on line 3, the following will show:

  1 `project/`
  2 `  deeply/nested/file.txt`
  3   `folder/`
  4     |
  5 `  other/nested/folder/`
  6   `file.txt`

  The cursor is placed on line 4 and nested "inside" this folder. Typing
  `/new/nested/file.txt` and pressing <cr> will create
  `/home/me/project/folder/new/nested/file.txt`.

  Finally, when the cursor is on the compressed path on line 2, by default
  the same rules apply as for regular file entries. In this case the base
  will be `/home/me/project/deeply/nested`:

  1 `project/`
  2 `+  deeply/nested/`
  3 `    file.txt`
  4     |
  5   `folder/`
  6 `  other/nested/folder/`
  7   `file.txt`

  Typing `/new/nested/file.txt` and pressing <cr> will create
  `/home/me/project/deeply/nested/new/nested/file.txt`.

  If the cursor was on line 4 instead of line 2, the base path would be
  `/home/me/project/other/nested/folder`:

  1 `project/`
  2 `  deeply/nested/file.txt`
  3   `folder/`
  4 `  other/nested/folder/`
  5     |
  6   `file.txt`

  Typing `/new/nested/file.txt` and pressing <cr> will create
  `/home/me/project/other/nested/folder/new/nested/file.txt`.

  This leaves us with one unresolved scenario, which is how to create files
  or directories at arbitrary parent directories of compressed paths.

  Support for this is implemented via `vim.v.count`. When a count is supplied to
  the mapping executing this function, if this count is greater than `0` then
  Carbon will count directories on compressed paths from left to right, and
  will create a file in the `vim.v.count` nth directory.

  Given the default |carbon-setting-actions-create| mapping of `c`, imagine we
  were on line 2 and pressed `1c`. This would show the following:

  1 `project/`
  2 `  deeply/`
  3 `    nested/file.txt`
  4     |
  3   `folder/`
  4 `  other/nested/folder/`
  5   `file.txt`

  Typing `/new/nested/file.txt` and pressing <cr> will create
  `/home/me/project/deeply/new/nested/file.txt`.

  For compressed paths which end in a directory the same rules apply except
  that by default, the current directory will be used as a base instead of the
  parent directory.

  Finally, when `vim.v.count` does not resolve to a directory, the default
  behavior as if no count was supplied will be executed.

  `------------------------------------------------------------------------------`
  delete                                                    *carbon-buffer-delete*

  Signature: `require('carbon.buffer').delete()`

  Prompts confirmation to delete the current entry under the cursor.
  When the current entry is a regular file or executable the file itself will be
  removed. When it is a directory, the directory and all its contents will be
  removed recursively. Finally, when it is a symlink, just the symlink will be
  removed.

  A [count] can be specified to start deleting from left-to-right. This is
  useful when the cursor is currently positioned on a compressed path.
  It is recommended to familiarize yourself with |carbon-setting-compress| before
  reading on as most of the different scenarios involve compressed paths.

  Imagine the following directory structure with Neovim opened in
  a `/home/me/project` directory:

  1 `project/`
  2 `  deeply/nested/file.txt`
  3   `folder/`
  4 `  other/nested/folder/`
  5   `file.txt`

  If we want to delete the file on line 5 then we can by pressing the mapping
  for |carbon-setting-actions-delete|. After doing so the buffer automatically
  updates to reflect the changes:

  1 `project/`
  2 `  deeply/nested/file.txt`
  3   `folder/`
  4 `  other/nested/folder/`

  If we want to delete the `folder/` directory on line 4, we can once again do
  so by pressing the delete mapping. By default, Carbon deletes from right to
  left. The rationale here is based on an assumption that most of the time
  you'll likely find yourself wanting to delete single files so the behaviour
  is streamlined for this use-case.

  Specifying a [count] will reverse the direction so it will delete from left
  to right instead, allowing for deletion of folders at any level of nesting
  in a compressed path. If instead of `folder/` on line 4 we wanted to delete
  `nested` we would prefix the mapping with the number `2` e.g. pressing `2d`
  and confirming deletion on line 4 would result in:

  1 `project/`
  2 `  deeply/nested/file.txt`
  3   `folder/`
  4 `  other/`

  If we wanted to delete the `deeply/` folder on line 2, we would press `1d`
  and confirm deletion, this would leave:

  1 `project/`
  2   `folder/`
  3 `  other/`

  The [count] is clamped. If it exceeds the amount of "components" in the path
  then it will select the last component (the actual entry of that line).

  `------------------------------------------------------------------------------`
  move                                                        *carbon-buffer-move*

  Signature: `require('carbon.buffer').move()`

  Prompts the user for a new destination for the entry below the cursor.
  A [count] can be supplied to move starting from left to right on compressed
  paths. The [count] is clamped. If it exceeds the amount of "components" in the
  path then it will select the last component (the actual entry of that line).

  Intermediate directories will be created if they do not exist.

================================================================================
WATCHER                                                           *carbon-watcher*

  Usage: `require('carbon.watcher')`

  This module provides a thin wrapper around `vim.loop.new_fs_event`, see
  |watch-file| for more information about `vim.loop.new_fs_event`. Paths can
  be registered using |carbon-watcher-register|, once registered, any change
  to that path will cause an event to be emitted. Registered paths can be
  released using |carbon-watcher-release|. Releasing a path will stop the
  watcher for that path.

  If the path parameter of either of these functions is a directory, then that
  directory and all its children files and directories will be listened to.
  Carbon itself only listens to directories to reduce the amount of file
  watching this plugin does. A single watcher is created for each unique
  directory whose children have been traversed.

  Finally, |carbon-watcher-on| and |carbon-watcher-off| can be used to
  register callbacks on arbitrary events.

  The watcher itself only emits `carbon:synchronize` events to allow the
  buffer to respond to relevant changes to the current working directory.

  The `carbon:synchronize` event is a built-in event.
  See the list of built-in commands below for details about built-in events:

                                                  *carbon-watcher-built-in-events*

  Name:        `carbon:synchronize`
  Description: Used by |carbon-watcher| when listening for file system changes.

  `------------------------------------------------------------------------------`
  on                                                           *carbon-watcher-on*

  Signature: `require('carbon.watcher').on(`{event}, {callback}`)`

  Both {event} and {callback} are required.

  - {event} can be a table of event names or a string event name.
  - {callback} must be |vim.is_callable|.

  {event} can be any arbitrary string since anything can be emitted via
  |carbon-watcher-emit|.

                                                           *carbon-watcher-on-all*

  When {event} is set to `'*'` then {callback} is triggered for any event.
  Like any other event, {callback} which are bound to `'*'` can be cleared
  with |carbon-watcher-off|.

                                                      *carbon-watcher-on-callback*

  {callback} will receive the {event} which triggered it, and the {path}
  (absolute parent directory), {filename} (modified file), and {error} (if any).

  `function callback(`{event}, {dirpath}, {filename}, {error}`)`
  `  print(vim.inspect(`{event}, {dirpath}, {filename}, {error}`))`
  `end`

  `require('carbon.watcher').on('*', callback)`

  will listen to the `change` and `rename` events which are triggered by
  changes to paths registered with |carbon-watcher-register|.
  See |carbon-watcher-built-in-events| for a list of built-in events.

  In the call to `on` the callback was not passed as a closure but as a
  function reference, this allows clearing that specific callback with
  |carbon-watcher-off|. Anonymous closures can only be removed by clearing
  everything and should not be used.

  `------------------------------------------------------------------------------`
  off                                                         *carbon-watcher-off*

  Signature: `require('carbon.watcher').off(`[{event}[, {callback}]]`)`

  When called without arguments, clears all callbacks attached to any event
  including `'*'`:

  When called with just {event} clears the given event name if it is a string,
  or calls `off` again with each value in the {event} table.

  When called with {event} and {callback}, clears specified {callback} from
  {event} as described above.

  `------------------------------------------------------------------------------`
  emit                                                       *carbon-watcher-emit*

  Signature: `require('carbon.watcher').emit(`{event}[, {...varargs}]`)`

  Emits {event} with {event} as first argument and remaining {...varargs}
  as varargs arguments to registered callbacks. The {event} can be any string.

  After executing callbacks registered to {event}, all callbacks registered to
  `'*'` will be executed. See |carbon-watcher-on-all|

  NOTE: there are some events which carbon.nvim uses internally. See
  |carbon-watcher-built-in-events| for a list of built-in events.

  `------------------------------------------------------------------------------`
  keep                                                       *carbon-watcher-keep*

  Signature: `require('carbon.watcher').keep(`{callback}`)`

  Calls {callback} for each `path` which is currently being listened to.
  When {callback} returns `true` for a `path`, it will be kept.
  Otherwise, when `false` is returned |carbon-watcher-release| will be
  called with `path`.

  `------------------------------------------------------------------------------`
  release                                                 *carbon-watcher-release*

  Signature: `require('carbon.watcher').release(`[{path}]`)`

  Unregister a {path} registered by |carbon-watcher-register|. If {path} is not
  registered then every registered path will be released.

  `------------------------------------------------------------------------------`
  register                                               *carbon-watcher-register*

  Signature: `require('carbon.watcher').register(`{path}`)`

  Register an absolute {path}. Once registered, any changes made to this path
  will emit events based on events received from Neovim's Lua |vim.loop| api.

  See |carbon-watcher-built-in-events| for a list of built-in events.

  `------------------------------------------------------------------------------`
  has                                                         *carbon-watcher-has*

  Signature: `require('carbon.watcher').has(`{event}, {callback}`)`

  Returns `true` if {callback} is registered for {event} or `false` otherwise.

  `------------------------------------------------------------------------------`
  registered                                           *carbon-watcher-registered*

  Signature: `require('carbon.watcher').registered()`

  Returns a table of paths registered via |carbon-watcher-register|.

================================================================================
SETTINGS                                                         *carbon-settings*

  Usage: `require('carbon.settings')`

  Stores all the settings Carbon needs to function properly, it does not expose
  any methods of its own. See below for a table with references to helptags:

                                                           *carbon-settings-table*

  `{`
    `sync_pwd      = `|carbon-setting-sync-pwd|`,`
  `  compress      = `|carbon-setting-compress|`,`
  `  auto_open     = `|carbon-setting-auto-open|`,`
  `  keep_netrw    = `|carbon-setting-keep-netrw|`,`
  `  sync_on_cd    = `|carbon-setting-sync-on-cd|`,`
  `  sync_delay    = `|carbon-setting-sync-delay|`,`
  `  sidebar_width = `|carbon-setting-sidebar-width|`,`
  `  always_reveal = `|carbon-setting-always-reveal|`,`
  `  exclude       = `|carbon-setting-exclude|`,`

  `  indicators = {`
  `    expand   = `|carbon-setting-indicators-expand|`,`
  `    collapse = `|carbon-setting-indicators-collapse|`,`
  `  },`

    `flash = {`
      `delay    = `|carbon-setting-flash-delay|`,`
      `duration = `|carbon-setting-flash-duration|`,`
    `},`

  `  actions = {`
  `    up               = `|carbon-setting-actions-up|`,`
  `    down             = `|carbon-setting-actions-down|`,`
  `    edit             = `|carbon-setting-actions-edit|`,`
  `    reset            = `|carbon-setting-actions-reset|`,`
  `    split            = `|carbon-setting-actions-split|`,`
  `    vsplit           = `|carbon-setting-actions-vsplit|`,`
  `    quit             = `|carbon-setting-actions-quit|`,`
  `    create           = `|carbon-setting-actions-create|`,`
  `    move             = `|carbon-setting-actions-move|`,`
  `    delete           = `|carbon-setting-actions-delete|`,`
  `    close_parent     = `|carbon-setting-actions-close-parent|`,`
  `    toggle_recursive = `|carbon-setting-actions-toggle-recursive|`,`
  `  },`

  `  highlights = {`
  `    CarbonDir           = `|carbon-setting-highlights-CarbonDir|`,`
  `    CarbonFile          = `|carbon-setting-highlights-CarbonFile|`,`
  `    CarbonExe           = `|carbon-setting-highlights-CarbonExe|`,`
  `    CarbonSymlink       = `|carbon-setting-highlights-CarbonSymlink|`,`
  `    CarbonBrokenSymlink = `|carbon-setting-highlights-CarbonBrokenSymlink|`,`
  `    CarbonIndicator     = `|carbon-setting-highlights-CarbonIndicator|`,`
  `    CarbonDanger        = `|carbon-setting-highlights-CarbonDanger|`,`
  `    CarbonPending       = `|carbon-setting-highlights-CarbonPending|`,`
  `    CarbonFlash         = `|carbon-setting-highlights-CarbonFlash|`,`
  `  },`
  `}`

  Each specific setting is detailed in this module's documentation.

  `------------------------------------------------------------------------------`
  sync_pwd                                               *carbon-setting-sync-pwd*

  Default: `false`

  When enabled, Carbon updates Vim's |pwd| to match the new root path whenever
  the buffer root changes.

  `------------------------------------------------------------------------------`
  compress                                               *carbon-setting-compress*

  Default: `true`

  When enabled, allows Carbon to compress deeply nested children as long as
  they only contain a single child and |carbon-entry-is-compressible| is `true`.
  For example, take the following structure:
>
  pwd
  |-- a/
  |-- |-- b/
  |-- |-- |-- c/
  |-- |-- |-- |-- d.txt
  |-- t/
  |-- |-- u/
  |-- |-- |-- v.txt
  |-- |-- |-- w.txt
  |-- |-- x/
  |-- |-- |-- y/
  |-- |-- |-- |-- z.txt
<
  We see here that `a/` contains a single child `b/` which contains a
  single child `c/` which contains a single child `d.txt`. We can also see
  that `t/` contains two children, `u/` which contains `v.txt` and `w.txt`, and `x/`
  which contains a single child `y` which contains a single child `z.txt`. When
  compression is enabled, Carbon shows the above structure like this:
>
  pwd/
    a/b/c/d.txt
  + v/
<
  Because `a/`, `b/`, `c/`, and `d.txt` are all only children of their parent,
  this path can be compressed to the point where we can directly see `d.txt`
  even though it is nested quite deep in the directory tree. For the other
  directory `t/` however, no compression can take place at the top level
  because `t/` itself contains two children. If we open `t/` however, you will
  see the following:
>
  pwd/
    a/b/c/d.txt
  - t/
    + u/
      x/y/z.txt
<
  We see here that `u/` is not expanded because it contains two children,
  `v.txt` and `w.txt` whereas `x/`, `y/`, and `z.txt` are all only children of
  their parent which means those can be compressed.

  `------------------------------------------------------------------------------`
  auto_open                                             *carbon-setting-auto-open*

  Default: `true`

  When enabled and Neovim is opened with a directory path argument, Carbon's
  buffer will open immediately.

  `------------------------------------------------------------------------------`
  keep_netrw                                           *carbon-setting-keep-netrw*

  Default: `false`

  Sets both `vim.g.loaded_netrw` and `vim.g.loaded_netrwPlugin` to `1` and
  deletes |augroup| `FileExplorer` and `Network`.

  When `true` NetRW will not be harmed by Carbon. This also means that
  `Explore` and `Lexplore` are no longer aliased to `Carbon` and `Lcarbon` anymore.

  This does not prevent Carbon from showing on vim startup instead of NetRW.
  To control this behavior, see |carbon-setting-auto-open|.

  `------------------------------------------------------------------------------`
  sync_on_cd                                           *carbon-setting-sync-on-cd*

  Default: `not vim.opt.autochdir:get()`

  Disabled by default when |autochdir| is set to `1`, enabled by default when
  |autochdir| set to `0`. When enabled, Carbon listens for `:cd` commands.
  Once a `:cd` command is executed Carbon will automatically update
  |carbon-buffer-data-root| to that path.

  `------------------------------------------------------------------------------`
  sync_delay                                           *carbon-setting-sync-delay*

  Default: `20`

  The amount of milliseconds to wait before updating and rerendering the
  buffer. Carbon debounces file system events by default to reduce the amount
  of updating and rerendering.

  `------------------------------------------------------------------------------`
  sidebar_width                                     *carbon-setting-sidebar-width*

  Default: `30`

  The width in columns of the sidebar window opened by |carbon-command-Lcarbon|.

  `------------------------------------------------------------------------------`
  always_reveal                                     *carbon-setting-always-reveal*

  Default: `false`

  By default, only the <bang> versions of all |carbon-commands| will reveal
  the current buffer. Enabling this will cause all versions of these commands
  to reveal the current buffer.

  `------------------------------------------------------------------------------`
  exclude                                                 *carbon-setting-exclude*

  Default: >
    {
      '~$',
      '#$',
      '%.git$',
      '%.bak$',
      '%.rbc$',
      '%.class$',
      '%.sw[a-p]$',
      '%.py[cod]$',
      '%.Trashes$',
      '%.DS_Store$',
      'Thumbs%.db$',
      '__pycache__',
      'node_modules',
    }
<
  Paths matching any Lua pattern are filtered removed. For more information
  about these patterns, see: https://www.lua.org/pil/20.2.html.
  This setting may be set to `nil` to show everything.

  `------------------------------------------------------------------------------`
  indicators                                           *carbon-setting-indicators*

  Default:
    `{`
    `  expand = '+',`                             *carbon-setting-indicators-expand*
    `  collapse = '-',`                         *carbon-setting-indicators-collapse*
    `}`

  Controls the expand and collapse indicators shown before a directory. Using
  more than one character is allowed. This setting may be set to `nil` to
  disable indicators. Individual indicators can also be disabled by setting
  them to `nil`.

  `------------------------------------------------------------------------------`
  flash                                                     *carbon-setting-flash*

  Default:
    `{`
    `  delay = 50,`                                     *carbon-setting-flash-delay*
    `  duration = 500,`                              *carbon-setting-flash-duration*
    `}`

  Controls highlight {delay} and {duration} for entries revealed by
  |carbon-buffer-expand-to-path|. Setting it to `nil` will disable
  highlighting of revealed entries.

  Uses |carbon-setting-highlights-CarbonFlash| to highlight the revealed entry.

  `------------------------------------------------------------------------------`
  float_settings                                   *carbon-setting-float-settings*

  Default: >
    function()
      local columns = vim.opt.columns:get()
      local rows = vim.opt.lines:get()
      local width = math.min(50, columns * 0.8)
      local height = math.min(20, rows * 0.8)

      return {
        relative = 'editor',
        style = 'minimal',
        border = 'single',
        width = width,
        height = height,
        col = math.floor(columns / 2 - width / 2),
        row = math.floor(rows / 2 - height / 2 - 2),
      }
    end
<
  This setting controls the window settings used in floating windows spawned
  via |carbon-command-Fcarbon|. When set to a table, this table will be passed to
  |nvim_open_win| directly.

  When set to a function, the function will be executed and its return value
  must be a table which will then be passed to |nvim_open_win|. The function
  form allows you to specify the size based on the current dimensions of the
  editor which is not possible when passing a table directly.

  The default function will create a horizontally and vertically centered
  popup with a maximum width of 80% up to 50 columns and maximum height of 80%
  up to 20 lines. All dimensions and offsets will be based on the current
  dimensions of the editor when this function is called.

  `------------------------------------------------------------------------------`
  actions                                                 *carbon-setting-actions*

  Default:
    `{`
    `  up = '[',`                                        *carbon-setting-actions-up*
    `  down = ']',`                                    *carbon-setting-actions-down*
    `  quit = 'q',`                                    *carbon-setting-actions-quit*
    `  edit = '<cr>',`                                 *carbon-setting-actions-edit*
    `  move = 'm',`                                    *carbon-setting-actions-move*
    `  reset = '.',`                                  *carbon-setting-actions-reset*
    `  split = '<c-x>',`                              *carbon-setting-actions-split*
    `  vsplit = '<c-v>',`                            *carbon-setting-actions-vsplit*
    `  create = 'c',`                                *carbon-setting-actions-create*
    `  delete = 'd',`                                *carbon-setting-actions-delete*
    `  close_parent = '-',`                    *carbon-setting-actions-close-parent*
    `  toggle_recursive = '!',`            *carbon-setting-actions-toggle-recursive*
    `}`

  Default mappings for |carbon-plugs|. Setting this to `nil` will prevent
  Carbon from creating any mapping. Setting one of its properties to `nil`
  will disable the mapping for that specific property.

  More than one key may be mapped to an action by supplying a table of keys.
  For example mapping |carbon-setting-actions-reset| to `,` in addition to `.`
  looks like the following:

  `reset = { '.', ',' },`

  Each property maps to a |<Plug>| mapping defined in |carbon-plugs|:

  `up`               => |carbon-plug-up|
  `down`             => |carbon-plug-down|
  `quit`             => |carbon-plug-quit|
  `edit`             => |carbon-plug-edit|
  `move`             => |carbon-plug-move|
  `reset`            => |carbon-plug-reset|
  `split`            => |carbon-plug-split|
  `vsplit`           => |carbon-plug-vsplit|
  `create`           => |carbon-plug-create|
  `delete`           => |carbon-plug-delete|
  `close_parent`     => |carbon-plug-close-parent|
  `toggle_recursive` => |carbon-plug-toggle-recursive|

  `------------------------------------------------------------------------------`
  highlights                                           *carbon-setting-highlights*

  Default:
    `{`
    `  CarbonDir = {`                          *carbon-setting-highlights-CarbonDir*
    `    link = 'Directory',`
    `  },`
    `  CarbonFile = {`                        *carbon-setting-highlights-CarbonFile*
    `    link = 'Text',`
    `  },`
    `  CarbonExe = {`                          *carbon-setting-highlights-CarbonExe*
    `    fg = '#22cc22',`
    `    ctermfg = 'Green',`
    `    bold = true,`
    `  },`
    `  CarbonSymlink = {`                  *carbon-setting-highlights-CarbonSymlink*
    `    fg = '#d77ee0',`
    `    ctermfg = 'Magenta',`
    `    bold = true,`
    `  },`
    `  CarbonBrokenSymlink = {`      *carbon-setting-highlights-CarbonBrokenSymlink*
    `    fg = '#ea871e',`
    `    ctermfg = 'Brown',`
    `    bold = true,`
    `  },`
    `  CarbonIndicator = {`              *carbon-setting-highlights-CarbonIndicator*
    `    fg = 'Gray',`
    `    ctermfg = 'DarkGray',`
    `    bold = true,`
    `  },`
    `  CarbonDanger = {`                    *carbon-setting-highlights-CarbonDanger*
    `    fg = '#ff3333',`
    `    ctermfg = 'Red',`
    `    bold = true,`
    `  },`
    `  CarbonPending = {`                  *carbon-setting-highlights-CarbonPending*
    `    fg = '#ffee00',`
    `    ctermfg = 'Yellow',`
    `    bold = true,`
    `  },`
    `  CarbonFlash = {`                      *carbon-setting-highlights-CarbonFlash*
    `    link = 'Visual',`
    `  },`
    `}`

  The full highlighting configuration used by Carbon. Each key of the table
  below will become a highlight group. The table of properties attached to each
  key will determine how the final generated highlight group will look. Any
  valid option accepted by |nvim_set_hl| is also valid in the table of
  properties for a key.

  The `highlights` setting may be set to `nil` to prevent any highlight groups
  from being generated.

vim:ft=help
